### FILE: ./conftest.py
# pillsbot/tests/conftest.py
import sys
from pathlib import Path

# This file is at <project_root>/pillsbot/tests/conftest.py
# Project root is two levels up from here.
ROOT = Path(__file__).resolve().parents[2]  # -> /home/igor/med
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))


### FILE: ./integration/test_retry_and_escalation.py
# tests/integration/test_retry_and_escalation.py
import asyncio
import pytest
from datetime import datetime, timedelta

from pillsbot.core.reminder_engine import ReminderEngine
from pillsbot import config as cfg

class FakeAdapter:
    def __init__(self):
        self.sent = []

    async def send_group_message(self, group_id, text, reply_markup=None):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))

class NoOpScheduler:
    def __init__(self): pass
    def add_job(self, *args, **kwargs): pass

def make_engine(interval=0.05, max_attempts=2):
    now = datetime.now(cfg.TZ)
    dose_time = (now + timedelta(seconds=0.1)).strftime("%H:%M")
    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        RETRY_INTERVAL_S = interval
        MAX_RETRY_ATTEMPTS = max_attempts
        TAKING_GRACE_INTERVAL_S = 0
        PATIENTS = [{
            "patient_id": 10,
            "patient_label": "P",
            "group_id": -10,
            "nurse_user_id": 20,
            "doses": [{"time": dose_time, "text": "X"}],
        }]
    eng = ReminderEngine(Cfg, FakeAdapter())
    return eng

@pytest.mark.asyncio
async def test_retry_and_escalation():
    eng = make_engine(interval=0.05, max_attempts=2)
    await eng.start(NoOpScheduler())
    # Manually trigger the job (simulate scheduler firing)
    dose_key = list(eng.state.keys())[0]
    await eng._start_dose_job(patient_id=dose_key.patient_id, time_str=dose_key.time_str)
    # Wait enough for retries + escalation
    await asyncio.sleep(0.25)
    # Check an escalation happened (nurse DM sent)
    assert any(kind == "dm" for (kind, _, _) in eng.adapter.sent)


### FILE: ./test_adapter_flow.py
# tests/test_adapter_flow.py
import pytest
from unittest.mock import AsyncMock, Mock
from pillsbot.adapters.telegram_adapter import TelegramAdapter


@pytest.mark.asyncio
async def test_on_group_text_forwards_to_engine(monkeypatch):
    # Patch aiogram.Bot to avoid network/token validation
    class DummyBot:
        def __init__(self, *a, **k):
            pass

    # Fake Dispatcher with non-async register methods to avoid warnings
    class DummyDispatcher:
        def __init__(self):
            self.message = Mock()
            self.callback_query = Mock()

        def start_polling(self, bot):
            pass

    monkeypatch.setattr("pillsbot.adapters.telegram_adapter.Bot", DummyBot)
    monkeypatch.setattr(
        "pillsbot.adapters.telegram_adapter.Dispatcher", DummyDispatcher
    )

    mock_engine = AsyncMock()
    adapter = TelegramAdapter(
        "123456:ABCDEF-test", engine=mock_engine, patient_groups=[-100]
    )

    msg = type("M", (), {})()
    msg.chat = type("C", (), {"id": -100})()
    msg.text = "hi"
    msg.from_user = type("U", (), {"id": 1})()

    await adapter.on_group_text(msg)
    assert mock_engine.on_patient_message.await_count == 1


### FILE: ./test_inline_confirm.py
# tests/test_inline_confirm.py
import pytest
from pillsbot.core.reminder_engine import ReminderEngine, DoseKey, Status
import pillsbot.config as cfg


class FakeAdapter:
    def __init__(self):
        self.sent = []  # (kind, id, text)

    async def send_group_message(self, group_id, text, reply_markup=None):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))


@pytest.mark.asyncio
async def test_text_confirmation_confirms_when_awaiting():
    eng = ReminderEngine(cfg, adapter=FakeAdapter())
    await eng.start(None)

    # Pick first patient & dose and mark it as awaiting
    patient = list(eng.patient_index.values())[0]
    key = DoseKey(patient["patient_id"], eng.clock.today_str(), patient["doses"][0]["time"])
    inst = eng.state_mgr.get(key)
    eng.state_mgr.set_status(inst, Status.AWAITING)

    # Send a confirmation text
    from datetime import UTC, datetime as dt
    msg = type("Msg", (), dict(
        group_id=patient["group_id"],
        sender_user_id=patient["patient_id"],
        text="ок",
        sent_at_utc=dt.now(UTC),
    ))()
    await eng.on_patient_message(msg)

    # Engine should confirm and send an ack
    assert eng.state_mgr.status(inst) == Status.CONFIRMED
    assert any("Готово! Зафіксовано" in t for _, _, t in eng.adapter.sent)


### FILE: ./test_scheduler_wiring.py


### FILE: ./unit/test_matcher.py
# tests/unit/test_matcher.py
from pillsbot.core.matcher import Matcher
from pillsbot import config as cfg


def test_matcher_positive_cases():
    # Use the same patterns as production config to keep tests realistic
    m = Matcher(cfg.CONFIRM_PATTERNS)
    for txt in ["Ок", "+", "так", "окей", "прийняв", "прийняла"]:
        assert m.matches_confirmation(txt)


def test_matcher_negative_cases():
    # Narrow pattern to ensure boundaries work as intended
    m = Matcher([r"\bтак\b"])
    assert not m.matches_confirmation("також")  # word boundary prevents false positive
    assert not m.matches_confirmation("random text")


### FILE: ./unit/test_measurements_flow.py
# tests/unit/test_measurements_flow.py
import os
from datetime import UTC, datetime

from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg


class FakeAdapter:
    def __init__(self):
        self.sent = []  # (kind, id, text)

    async def send_group_message(self, group_id, text, reply_markup=None):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))


class NoOpScheduler:
    def add_job(self, *args, **kwargs):
        pass


def _cleanup_csvs(tmp_suffix: str):
    paths = [
        f"pillsbot/logs/pressure_{tmp_suffix}.csv",
        f"pillsbot/logs/weight_{tmp_suffix}.csv",
    ]
    for p in paths:
        try:
            os.remove(p)
        except FileNotFoundError:
            pass


def make_engine(tmp_suffix="x"):
    # Ensure a clean slate for this test run
    _cleanup_csvs(tmp_suffix)

    # Use test-specific CSV paths to avoid touching prod logs
    MEASURES = {k: dict(v) for k, v in cfg.MEASURES.items()}
    MEASURES["pressure"] = dict(
        MEASURES["pressure"], csv_file=f"pillsbot/logs/pressure_{tmp_suffix}.csv"
    )
    MEASURES["weight"] = dict(
        MEASURES["weight"], csv_file=f"pillsbot/logs/weight_{tmp_suffix}.csv"
    )

    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        MEASURES = {}  # set right after the class definition
        RETRY_INTERVAL_S = 0.05
        MAX_RETRY_ATTEMPTS = 2
        TAKING_GRACE_INTERVAL_S = 60
        PATIENTS = [
            {
                "patient_id": 100,
                "patient_label": "P",
                "group_id": -100,
                "nurse_user_id": 200,
                "doses": [],
                "measurement_checks": [{"measure_id": "pressure", "time": "23:59"}],
            }
        ]

    # IMPORTANT: assign here to avoid NameError inside class scope
    Cfg.MEASURES = MEASURES

    eng = ReminderEngine(Cfg, FakeAdapter())
    return eng


import pytest


@pytest.mark.asyncio
async def test_measurement_ack_and_csv():
    eng = make_engine(tmp_suffix="flow1")
    await eng.start(NoOpScheduler())
    # Send a good pressure message (TWO values now)
    msg = IncomingMessage(
        group_id=-100,
        sender_user_id=100,
        text="BP 120/80",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)
    # Should have ack line for pressure
    assert any("Записав тиск" in t for _, _, t in eng.adapter.sent)


@pytest.mark.asyncio
async def test_daily_missing_then_ok():
    eng = make_engine(tmp_suffix="flow2")
    await eng.start(NoOpScheduler())

    # First check: no entry today -> engine currently sends 'unknown_text' for pressure/weight
    await eng._job_measure_check(patient_id=100, measure_id="pressure")
    assert any("Не розпізнав" in t for _, _, t in eng.adapter.sent)
    eng.adapter.sent.clear()

    # Now record a measurement (this will produce an ACK message)
    msg = IncomingMessage(
        group_id=-100,
        sender_user_id=100,
        text="pressure 120 80",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)
    assert any("Записав тиск" in t for _, _, t in eng.adapter.sent)

    # Check again: should NOT send any new message
    before = len(eng.adapter.sent)
    await eng._job_measure_check(patient_id=100, measure_id="pressure")
    after = len(eng.adapter.sent)
    assert before == after  # no additional messages


### FILE: ./unit/test_measurements_parsing.py
# tests/unit/test_measurements_parsing.py
from pillsbot.core.measurements import MeasurementRegistry
from pillsbot import config as cfg


def make_registry():
    return MeasurementRegistry(cfg.TZ, cfg.MEASURES)


def test_pressure_positive_cases():
    reg = make_registry()
    mid, body = reg.match("тиск 120 80")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("BP 118/79")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("давление 125,85")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]

    # punctuation after keyword
    mid, body = reg.match("BP: 120/80")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]


def test_pressure_negative_cases():
    reg = make_registry()
    mid, body = reg.match("pressure 120")  # missing one value
    assert mid == "pressure"
    assert not reg.parse(mid, body)["ok"]

    mid, body = reg.match("давление 120.5/80")  # decimal not allowed
    assert mid == "pressure"
    assert not reg.parse(mid, body)["ok"]


def test_weight_positive_cases():
    reg = make_registry()
    mid, body = reg.match("вага 102,4")
    assert mid == "weight"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("weight 73.0")
    assert mid == "weight"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("вес 80")
    assert mid == "weight"
    assert reg.parse(mid, body)["ok"]

    # boundaries
    mid, body = reg.match("weight 0")
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("weight 0.0")
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("weight 350.1234")
    assert reg.parse(mid, body)["ok"]


def test_weight_negative_cases():
    reg = make_registry()
    mid, body = reg.match("weight -5")
    r = reg.parse(mid, body)
    assert not r["ok"]

    mid, body = reg.match("взвешивание 80 кг")
    r = reg.parse(mid, body)
    assert not r["ok"]


def test_start_anchored():
    reg = make_registry()
    assert reg.match("моє давление 120 80") is None


### FILE: ./unit/test_preconfirm.py
# tests/unit/test_preconfirm.py
import pytest
from datetime import UTC, datetime
from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
import pillsbot.config as cfg


class FakeAdapter:
    def __init__(self):
        self.sent = []

    async def send_group_message(self, group_id, text, reply_markup=None):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))


@pytest.mark.asyncio
async def test_confirmation_without_awaiting_is_unknown():
    eng = ReminderEngine(cfg, adapter=FakeAdapter())
    await eng.start(None)

    msg = IncomingMessage(
        group_id=cfg.PATIENTS[0]["group_id"],
        sender_user_id=cfg.PATIENTS[0]["patient_id"],
        text="так",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)

    assert any("Не розпізнав" in t for _, _, t in eng.adapter.sent)


### FILE: ./unit/test_retry_semantics.py


### FILE: ./unit/test_validation_config.py
# tests/unit/test_validation_config.py
import pytest
from pillsbot.core.config_validation import validate_config
from zoneinfo import ZoneInfo


class CfgOk:
    TZ = ZoneInfo("Europe/Kyiv")
    MEASURES = {
        "pressure": {
            "label": "Тиск",
            "patterns": ["тиск", "давление", "BP", "pressure"],
            "csv_file": "pillsbot/logs/pressure_test.csv",
            "parser_kind": "int2",  # v4: two integers (systolic, diastolic)
            "separators": [" ", ",", "/"],
        }
    }
    PATIENTS = [
        {
            "patient_id": 1,
            "patient_label": "A",
            "group_id": -1,
            "nurse_user_id": 2,
            "doses": [{"time": "08:00", "text": "Med"}],
            "measurement_checks": [{"measure_id": "pressure", "time": "21:00"}],
        }
    ]


def test_validate_ok():
    validate_config(CfgOk)


def test_duplicate_measurement_check_times_raises():
    class CfgDup(CfgOk):
        PATIENTS = [
            {
                "patient_id": 1,
                "patient_label": "A",
                "group_id": -1,
                "nurse_user_id": 2,
                "doses": [{"time": "08:00", "text": "Med"}],
                "measurement_checks": [
                    {"measure_id": "pressure", "time": "21:00"},
                    {"measure_id": "pressure", "time": "21:00"},
                ],
            }
        ]

    with pytest.raises(ValueError):
        validate_config(CfgDup)


