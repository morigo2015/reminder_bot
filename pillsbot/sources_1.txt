### FILE: ./adapters/telegram_adapter.py
from __future__ import annotations

from datetime import datetime, timezone
from typing import Any, Iterable

from aiogram import Bot, Dispatcher, F
from aiogram.types import Message

# Import the dataclass defined at module scope in the engine
from pillsbot.core.reminder_engine import IncomingMessage


class TelegramAdapter:
    """Thin wrapper around aiogram to integrate with ReminderEngine."""

    def __init__(
        self, bot_token: str, engine: Any, patient_groups: Iterable[int]
    ) -> None:
        # aiogram Bot/Dispatcher
        self.bot = Bot(token=bot_token, parse_mode=None)
        self.dp = Dispatcher()

        # backrefs / config
        self.engine = engine
        self.patient_groups = set(patient_groups)

        # register handlers
        # We keep the filter simple and also re-check inside the handler
        self.dp.message.register(self.on_group_text, F.text)

    async def on_group_text(self, message: Message) -> None:
        """Handle text messages in patient group chats and forward to the engine."""
        chat_id = message.chat.id
        if chat_id not in self.patient_groups:
            return  # ignore messages from other chats

        text = message.text or ""
        sender_user_id = message.from_user.id if message.from_user else 0

        incoming = IncomingMessage(
            group_id=chat_id,
            sender_user_id=sender_user_id,
            text=text,
            sent_at_utc=datetime.now(timezone.utc),
        )

        await self.engine.on_patient_message(incoming)

    async def send_group_message(self, group_id: int, text: str) -> None:
        await self.bot.send_message(chat_id=group_id, text=text)

    async def send_nurse_dm(self, user_id: int, text: str) -> None:
        await self.bot.send_message(chat_id=user_id, text=text)

    async def run_polling(self) -> None:
        await self.dp.start_polling(self.bot)


__all__ = ["TelegramAdapter", "IncomingMessage"]


### FILE: ./app.py
from __future__ import annotations

import asyncio
from apscheduler.schedulers.asyncio import AsyncIOScheduler

from pillsbot import config as cfg
from pillsbot.core.reminder_engine import ReminderEngine
from pillsbot.adapters.telegram_adapter import TelegramAdapter


async def main() -> None:
    cfg.validate()
    token = cfg.get_bot_token()

    engine = ReminderEngine(cfg, adapter=None)  # temporary None to build adapter
    adapter = TelegramAdapter(token, engine, [p["group_id"] for p in cfg.PATIENTS])
    # back-reference
    engine.adapter = adapter

    scheduler = AsyncIOScheduler(timezone=cfg.TZ)
    await engine.start(scheduler)
    scheduler.start()

    # Run polling forever
    await adapter.run_polling()


if __name__ == "__main__":
    asyncio.run(main())


### FILE: ./config.py
"""
Runtime configuration for PillsBot.
All times for scheduling/logging are Europe/Kyiv.
"""

from __future__ import annotations

import os
from typing import Any
from zoneinfo import ZoneInfo

# Read from env by default for safety. You may hardcode for local dev.
BOT_TOKEN: str | None = (
    "550433191:AAFkG6atLs_uo0nwphtuiwbwIJeUhwfzCyI"  # fallback to env BOT_TOKEN if None
)
TIMEZONE = "Europe/Kyiv"
TZ = ZoneInfo(TIMEZONE)

# Retry/escalation config
RETRY_INTERVAL_S = 300  # I
MAX_RETRY_ATTEMPTS = 3  # N
TAKING_GRACE_INTERVAL_S = 600  # pre-confirm grace

# Regex patterns (case-insensitive search)
CONFIRM_PATTERNS = [r"OK", r"\bтак\b", r"\bвже\b", r"\bда\b", r"\+"]

LOG_FILE = "pillsbot/logs/pills.log"


# Patient roster (example/demo values; replace with real IDs)
PATIENTS: list[dict[str, Any]] = [
    {
        "patient_id": 382163513,  # Telegram user ID of patient
        "patient_label": "Іван Петров",
        "group_id": -1002690368389,  # Telegram group ID for this triad
        "nurse_user_id": 7391874317,  # Nurse personal account user ID
        "doses": [
            {"time": "08:30", "text": "Вітамін Д"},
            {"time": "20:00", "text": "Вітамін Д"},
        ],
    },
]


def get_bot_token() -> str:
    token = BOT_TOKEN or os.getenv("BOT_TOKEN")
    if not token:
        raise RuntimeError(
            "Bot token is not set. Set BOT_TOKEN in config.py or env var BOT_TOKEN."
        )
    return token


def validate() -> None:
    from datetime import datetime

    # Basic validation of patient config
    def parse_time_str(t: str) -> None:
        try:
            datetime.strptime(t, "%H:%M")
        except ValueError as e:
            raise ValueError(f"Invalid time '{t}', expected HH:MM") from e

    required_fields = {
        "patient_id",
        "patient_label",
        "group_id",
        "nurse_user_id",
        "doses",
    }
    for p in PATIENTS:
        missing = required_fields - set(p.keys())
        if missing:
            raise ValueError(f"Patient missing fields: {missing}")
        seen_times = set()
        for d in p["doses"]:
            t = d.get("time")
            if t in seen_times:
                raise ValueError(
                    f"Duplicate dose time for patient {p['patient_label']}: {t}"
                )
            seen_times.add(t)
            parse_time_str(t)
            if not d.get("text"):
                raise ValueError(
                    f"Dose text is required for patient {p['patient_label']} at {t}"
                )


### FILE: ./core/i18n.py
from __future__ import annotations

MESSAGES = {
    "reminder": "час прийняти {pill_text}",
    "repeat_reminder": "не отримано підтвердження",
    "confirm_ack": "підтвердження прийнято, дякую",
    "preconfirm_ack": "заздалегідь - теж ОК. Дякую",
    "too_early": "ще не на часі, чекайте нагадування",
    "escalate_group": "не отримано підтвердження, залучаємо мед.сестру",
    "escalate_dm": "пацієнт ({patient_label}): пропустив {date} {time}, {pill_text}",
}

def fmt(key: str, **kwargs) -> str:
    return MESSAGES[key].format(**kwargs)


### FILE: ./core/matcher.py
from __future__ import annotations

import re
from typing import Iterable

class Matcher:
    def __init__(self, patterns: Iterable[str]) -> None:
        pattern = "|".join(f"({p})" for p in patterns)
        self._rx = re.compile(pattern, re.IGNORECASE | re.UNICODE)

    def matches_confirmation(self, text: str) -> bool:
        return bool(self._rx.search(text or ""))

__all__ = ["Matcher"]


### FILE: ./core/reminder_engine.py
from __future__ import annotations

import asyncio
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, Optional, Any
from zoneinfo import ZoneInfo
import os

from pillsbot.core.matcher import Matcher
from pillsbot.core.i18n import fmt


@dataclass(frozen=True)
class DoseKey:
    patient_id: int
    date_str: str  # YYYY-MM-DD
    time_str: str  # HH:MM


@dataclass
class DoseInstance:
    dose_key: DoseKey
    patient_id: int
    patient_label: str
    group_id: int
    nurse_user_id: int
    pill_text: str
    scheduled_dt_local: datetime
    status: str = "Pending"  # Pending | AwaitingConfirmation | Confirmed | Escalated
    attempts_sent: int = 0
    preconfirmed: bool = False
    retry_task: Optional[asyncio.Task] = None


@dataclass
class IncomingMessage:
    group_id: int
    sender_user_id: int
    text: str
    sent_at_utc: datetime


class ReminderEngine:
    def __init__(self, config: Any, adapter: Any):
        self.cfg = config
        self.adapter = adapter
        self.tz: ZoneInfo = config.TZ
        self.matcher = Matcher(config.CONFIRM_PATTERNS)
        self.state: Dict[DoseKey, DoseInstance] = {}
        self.group_to_patient: Dict[int, int] = {
            p["group_id"]: p["patient_id"] for p in config.PATIENTS
        }
        self.patient_index: Dict[int, dict] = {
            p["patient_id"]: p for p in config.PATIENTS
        }
        os.makedirs(os.path.dirname(config.LOG_FILE), exist_ok=True)

    # --- Logging ---
    def _log(
        self,
        when_local: datetime,
        patient_id: int,
        patient_label: str,
        pill_text: str,
        status: str,
        attempts: int,
    ) -> None:
        line = f"{when_local.strftime('%Y-%m-%d %H:%M')}, {patient_id}, {patient_label}, {pill_text}, {status}, {attempts}\n"
        with open(self.cfg.LOG_FILE, "a", encoding="utf-8") as f:
            f.write(line)

    # --- Helpers ---
    def _today_str(self) -> str:
        return datetime.now(self.tz).strftime("%Y-%m-%d")

    def _local_now(self) -> datetime:
        return datetime.now(self.tz)

    def _get_dosekey(self, patient_id: int, date_str: str, time_str: str) -> DoseKey:
        return DoseKey(patient_id, date_str, time_str)

    def _ensure_today_instances(self) -> None:
        today = self._today_str()
        for p in self.cfg.PATIENTS:
            for d in p["doses"]:
                key = self._get_dosekey(p["patient_id"], today, d["time"])
                if key not in self.state:
                    hh, mm = map(int, d["time"].split(":"))
                    sched = datetime.now(self.tz).replace(
                        hour=hh, minute=mm, second=0, microsecond=0
                    )
                    inst = DoseInstance(
                        dose_key=key,
                        patient_id=p["patient_id"],
                        patient_label=p["patient_label"],
                        group_id=p["group_id"],
                        nurse_user_id=p["nurse_user_id"],
                        pill_text=d["text"],
                        scheduled_dt_local=sched,
                    )
                    self.state[key] = inst

    async def start(self, scheduler) -> None:
        """Prepare state and install daily jobs into the APScheduler."""
        self._ensure_today_instances()

        # Install daily cron jobs for each dose
        for p in self.cfg.PATIENTS:
            for d in p["doses"]:
                hh, mm = map(int, d["time"].split(":"))
                scheduler.add_job(
                    self._start_dose_job,
                    trigger="cron",
                    hour=hh,
                    minute=mm,
                    timezone=self.tz,
                    args=[p["patient_id"], d["time"]],
                    id=f"dose_{p['patient_id']}_{d['time']}",
                    replace_existing=True,
                )

    async def _start_dose_job(self, patient_id: int, time_str: str) -> None:
        """Called by scheduler at dose time in Europe/Kyiv."""
        self._ensure_today_instances()
        key = self._get_dosekey(patient_id, self._today_str(), time_str)
        inst = self.state.get(key)
        if not inst:
            return
        if inst.status == "Confirmed":
            return  # preconfirmed earlier

        # Send first reminder
        await self.adapter.send_group_message(
            inst.group_id, fmt("reminder", pill_text=inst.pill_text)
        )
        inst.status = "AwaitingConfirmation"
        inst.attempts_sent = 1

        # Start retry loop
        inst.retry_task = asyncio.create_task(self._retry_loop(inst))

    async def _retry_loop(self, inst: DoseInstance) -> None:
        I = self.cfg.RETRY_INTERVAL_S
        N = self.cfg.MAX_RETRY_ATTEMPTS
        # We already sent attempt #1 in _start_dose_job
        while inst.status == "AwaitingConfirmation":
            # Wait before deciding next action
            await asyncio.sleep(I)
            if inst.status != "AwaitingConfirmation":
                break
            if inst.attempts_sent < N:
                await self.adapter.send_group_message(
                    inst.group_id, fmt("repeat_reminder")
                )
                inst.attempts_sent += 1
            else:
                # escalate
                await self.adapter.send_group_message(
                    inst.group_id, fmt("escalate_group")
                )
                when = inst.scheduled_dt_local
                date = when.strftime("%Y-%m-%d")
                time = when.strftime("%H:%M")
                await self.adapter.send_nurse_dm(
                    inst.nurse_user_id,
                    fmt(
                        "escalate_dm",
                        patient_label=inst.patient_label,
                        date=date,
                        time=time,
                        pill_text=inst.pill_text,
                    ),
                )
                inst.status = "Escalated"
                self._log(
                    inst.scheduled_dt_local,
                    inst.patient_id,
                    inst.patient_label,
                    inst.pill_text,
                    "Escalated",
                    inst.attempts_sent,
                )
                break

    # --- Incoming messages from adapter ---
    async def on_patient_message(self, msg: IncomingMessage) -> None:
        # Only accept messages from known groups and from the patient user ID for that group
        pid = self.group_to_patient.get(msg.group_id)
        if pid is None or pid != msg.sender_user_id:
            return

        text = msg.text or ""
        if not self.matcher.matches_confirmation(text):
            return

        now_local = self._local_now()
        today = self._today_str()

        # Determine the relevant upcoming dose for today for this patient (next chronological)
        patient = self.patient_index[pid]
        upcoming: Optional[DoseInstance] = None
        min_dt = None
        for d in patient["doses"]:
            key = self._get_dosekey(pid, today, d["time"])
            inst = self.state.get(key)
            if not inst:
                continue
            if inst.status in ("Confirmed", "Escalated"):
                continue
            dt = inst.scheduled_dt_local
            if dt >= now_local and (min_dt is None or dt < min_dt):
                upcoming = inst
                min_dt = dt

        # If awaiting confirmation now for any dose, prioritize that instance
        awaiting_now: Optional[DoseInstance] = None
        for d in patient["doses"]:
            key = self._get_dosekey(pid, today, d["time"])
            inst = self.state.get(key)
            if inst and inst.status == "AwaitingConfirmation":
                awaiting_now = inst
                break

        target = awaiting_now or upcoming

        if target is None:
            # Nothing to confirm now; too early
            await self.adapter.send_group_message(patient["group_id"], fmt("too_early"))
            return

        # If we have an awaiting instance → normal confirmation
        if target.status == "AwaitingConfirmation":
            target.status = "Confirmed"
            if target.retry_task and not target.retry_task.done():
                target.retry_task.cancel()
            self._log(
                target.scheduled_dt_local,
                target.patient_id,
                target.patient_label,
                target.pill_text,
                "OK",
                target.attempts_sent,
            )
            await self.adapter.send_group_message(target.group_id, fmt("confirm_ack"))
            return

        # Else, we are before the first send for that dose; check grace
        delta = (target.scheduled_dt_local - now_local).total_seconds()
        if 0 <= delta <= self.cfg.TAKING_GRACE_INTERVAL_S:
            target.status = "Confirmed"
            target.preconfirmed = True
            target.attempts_sent = 0
            self._log(
                target.scheduled_dt_local,
                target.patient_id,
                target.patient_label,
                target.pill_text,
                "OK",
                0,
            )
            await self.adapter.send_group_message(
                target.group_id, fmt("preconfirm_ack")
            )
        else:
            await self.adapter.send_group_message(target.group_id, fmt("too_early"))


### FILE: ./__init__.py


### FILE: ./tests/integration/test_retry_and_escalation.py
import asyncio
import pytest
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg

class FakeAdapter:
    def __init__(self):
        self.sent = []

    async def send_group_message(self, group_id, text):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))

class NoOpScheduler:
    def __init__(self): pass
    def add_job(self, *args, **kwargs): pass

def make_engine(interval=0.05, max_attempts=2):
    now = datetime.now(cfg.TZ)
    dose_time = (now + timedelta(seconds=0.1)).strftime("%H:%M")
    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        RETRY_INTERVAL_S = interval
        MAX_RETRY_ATTEMPTS = max_attempts
        TAKING_GRACE_INTERVAL_S = 0
        PATIENTS = [{
            "patient_id": 10,
            "patient_label": "P",
            "group_id": -10,
            "nurse_user_id": 20,
            "doses": [{"time": dose_time, "text": "X"}],
        }]
    eng = ReminderEngine(Cfg, FakeAdapter())
    return eng

@pytest.mark.asyncio
async def test_retry_and_escalation():
    eng = make_engine(interval=0.05, max_attempts=2)
    await eng.start(NoOpScheduler())
    # Manually trigger the job (simulate scheduler firing)
    await eng._start_dose_job(patient_id=10, time_str=list(eng.state.keys())[0].time_str)
    # Wait enough for retries + escalation
    await asyncio.sleep(0.2)
    # Check an escalation happened
    assert any(kind=="dm" for (kind, _, _) in eng.adapter.sent)


### FILE: ./tests/unit/test_matcher.py
from pillsbot.core.matcher import Matcher

def test_matcher_positive_cases():
    m = Matcher([r"OK", r"\bтак\b", r"\bвже\b", r"\bда\b", r"\+"])
    for txt in ["Ок", "все ок!", "+", "да", "вже"]:
        assert m.matches_confirmation(txt)

def test_matcher_negative_cases():
    m = Matcher([r"\bтак\b"])
    assert not m.matches_confirmation("також")  # word boundary prevents false positive
    assert not m.matches_confirmation("random text")


### FILE: ./tests/unit/test_preconfirm_logic.py
import asyncio
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg

class FakeAdapter:
    def __init__(self):
        self.sent = []  # (chat_id, text)

    async def send_group_message(self, group_id, text):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))

def make_engine():
    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        RETRY_INTERVAL_S = 1
        MAX_RETRY_ATTEMPTS = 2
        TAKING_GRACE_INTERVAL_S = 60
        PATIENTS = [{
            "patient_id": 1,
            "patient_label": "Test Patient",
            "group_id": -1,
            "nurse_user_id": 2,
            "doses": [{"time": (datetime.now(cfg.TZ) + timedelta(minutes=1)).strftime("%H:%M"), "text": "Vit D"}],
        }]
    adapter = FakeAdapter()
    eng = ReminderEngine(Cfg, adapter)
    return eng, adapter

import pytest

@pytest.mark.asyncio
async def test_preconfirm_within_grace():
    eng, ad = make_engine()
    await eng.start(scheduler=type("S", (), {"add_job": lambda *a, **k: None})())  # no-op scheduler
    # Send a confirmation now; next dose is within 60s
    msg = IncomingMessage(group_id=-1, sender_user_id=1, text="ок", sent_at_utc=datetime.utcnow().astimezone(ZoneInfo("UTC")))
    await eng.on_patient_message(msg)
    # Expect preconfirm ack
    assert any("заздалегідь" in t for _,_,t in ad.sent)


