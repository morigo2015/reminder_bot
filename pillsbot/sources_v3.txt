### FILE: ./adapters/telegram_adapter.py
# pillsbot/adapters/telegram_adapter.py
from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import Any, Iterable, Optional

from aiogram import Bot, Dispatcher, F
from aiogram.types import (
    Message,
    CallbackQuery,
    ReplyKeyboardMarkup,
    KeyboardButton,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ForceReply,
)

from pillsbot.core.reminder_engine import IncomingMessage, DoseKey
from pillsbot.core.logging_utils import kv
from pillsbot.core.i18n import MESSAGES


class TelegramAdapter:
    """Thin wrapper around aiogram to integrate with ReminderEngine, plus v3 UI helpers."""

    def __init__(
        self, bot_token: str, engine: Any, patient_groups: Iterable[int]
    ) -> None:
        self.bot = Bot(token=bot_token, parse_mode=None)
        self.dp = Dispatcher()

        self.engine = engine
        self.patient_groups = set(patient_groups)

        self.log = logging.getLogger("pillsbot.adapter")

        # Text in groups
        self.dp.message.register(self.on_group_text, F.text)
        # Inline button callbacks (v3)
        self.dp.callback_query.register(
            self.on_callback_confirm, F.data.startswith("confirm:")
        )

    # ------------------------------------------------------------------------------
    # Handlers
    # ------------------------------------------------------------------------------
    async def on_group_text(self, message: Message) -> None:
        """Handle text messages in patient group chats and forward to the engine."""
        chat_id = message.chat.id
        text = message.text or ""
        sender_user_id = message.from_user.id if message.from_user else 0

        # Always log inbound traffic (messaging stays INFO)
        self.log.info(
            "msg.in.group "
            + kv(group_id=chat_id, sender_user_id=sender_user_id, text=text)
        )

        if chat_id not in self.patient_groups:
            self.log.debug("msg.in.ignored " + kv(reason="not a patient group"))
            return

        incoming = IncomingMessage(
            group_id=chat_id,
            sender_user_id=sender_user_id,
            text=text,
            sent_at_utc=datetime.now(timezone.utc),
        )

        await self.engine.on_patient_message(incoming)

    async def on_callback_confirm(self, callback: CallbackQuery) -> None:
        """
        Handle inline confirmation button presses.
        Passes through to engine for validation & state mutation,
        then answers the callback (ephemeral).
        """
        try:
            group_id = callback.message.chat.id if callback.message else 0
        except Exception:
            group_id = 0
        from_user_id = callback.from_user.id if callback.from_user else 0
        data = callback.data or ""
        message_id = callback.message.message_id if callback.message else None

        # Engine decides the outcome and any ephemeral text to show
        result: dict[str, Any] = await self.engine.on_inline_confirm(
            group_id=group_id,
            from_user_id=from_user_id,
            data=data,
            message_id=message_id,
        )
        cb_text: Optional[str] = result.get("cb_text")
        show_alert: bool = bool(result.get("show_alert", False))

        await self.answer_callback(callback.id, text=cb_text, show_alert=show_alert)

    # ------------------------------------------------------------------------------
    # Outbound messaging
    # ------------------------------------------------------------------------------
    async def send_group_message(
        self, group_id: int, text: str, reply_markup: Any | None = None
    ) -> int:
        """
        Sends a group message and returns Telegram message_id.
        Messaging-level logging remains at INFO.
        """
        self.log.info("msg.out.group " + kv(group_id=group_id, text=text))
        msg = await self.bot.send_message(
            chat_id=group_id, text=text, reply_markup=reply_markup
        )
        return msg.message_id

    async def send_nurse_dm(self, user_id: int, text: str) -> None:
        # Messaging → INFO
        self.log.info("msg.out.dm " + kv(user_id=user_id, text=text))
        await self.bot.send_message(chat_id=user_id, text=text)

    async def answer_callback(
        self, callback_query_id: str, text: str | None = None, show_alert: bool = False
    ) -> None:
        """Answer inline button press (ephemeral)."""
        await self.bot.answer_callback_query(
            callback_query_id, text=text or None, show_alert=show_alert
        )

    async def run_polling(self) -> None:
        self.log.debug("polling.run")
        # Ensure webhooks are disabled before getUpdates; drop any pending updates
        await self.bot.delete_webhook(drop_pending_updates=True)
        await self.dp.start_polling(self.bot)

    # ------------------------------------------------------------------------------
    # v3 UI helpers
    # ------------------------------------------------------------------------------
    def build_patient_reply_kb(self, patient: dict) -> ReplyKeyboardMarkup:
        """
        Fixed reply keyboard for the patient.
        Uses selective=True because this is a small private group.
        """
        kb = ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(text=MESSAGES["btn_pressure"]),
                    KeyboardButton(text=MESSAGES["btn_weight"]),
                ],
                [KeyboardButton(text=MESSAGES["btn_help"])],
            ],
            resize_keyboard=True,
            one_time_keyboard=False,
            is_persistent=True,
            selective=True,
            input_field_placeholder="Виберіть дію або введіть значення...",
        )
        return kb

    def build_confirm_inline_kb(self, dose_key: DoseKey) -> InlineKeyboardMarkup:
        """Inline 'confirm taken' button attached to reminder/retry messages."""
        data = f"confirm:{dose_key.patient_id}:{dose_key.date_str}:{dose_key.time_str}"
        kb = InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text=MESSAGES["btn_confirm_taken"], callback_data=data
                    )
                ]
            ]
        )
        return kb

    def build_force_reply(self) -> ForceReply:
        """ForceReply for guided input; selective=True as requested."""
        return ForceReply(selective=True)

    async def refresh_reply_keyboard(
        self, patient: dict, group_id: int | None = None
    ) -> Optional[int]:
        """
        Send a tiny follow-up message with the fixed reply keyboard to "refresh" it.
        Use visible text so clients don't drop it.
        Returns the sent message_id (or None on failure).
        """
        gid = group_id or patient["group_id"]
        try:
            text = "Оновив кнопки ↓"
            kb = self.build_patient_reply_kb(patient)
            self.log.info(
                "msg.out.group " + kv(group_id=gid, text="(keyboard refresh)")
            )
            msg = await self.bot.send_message(chat_id=gid, text=text, reply_markup=kb)
            return msg.message_id
        except Exception as e:
            self.log.error(
                "msg.out.group.error "
                + kv(group_id=gid, err=str(e), where="refresh_reply_keyboard")
            )
            return None


__all__ = [
    "TelegramAdapter",
    "IncomingMessage",
    "DoseKey",
]


### FILE: ./app.py
# pillsbot/app.py
from __future__ import annotations

import sys
from pathlib import Path
import asyncio
import logging

# --------------------------------------------------------------------------------------
# Ensure project root is in sys.path so "import pillsbot.*" always works
# --------------------------------------------------------------------------------------
ROOT = Path(__file__).resolve().parent.parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import config as cfg  # noqa: E402
from config import get_bot_token, PATIENTS  # noqa: E402
from pillsbot.core.reminder_engine import ReminderEngine  # noqa: E402
from pillsbot.adapters.telegram_adapter import TelegramAdapter  # noqa: E402
from apscheduler.schedulers.asyncio import AsyncIOScheduler  # noqa: E402


async def schedule_jobs(engine: ReminderEngine, timezone) -> AsyncIOScheduler:
    """
    Schedule daily dose reminders and measurement checks at exact times from config.
    """
    sched = AsyncIOScheduler(timezone=timezone)

    # Doses
    for p in PATIENTS:
        pid = p["patient_id"]
        for d in p["doses"]:
            hh, mm = (int(x) for x in d["time"].split(":"))
            sched.add_job(
                engine._start_dose_job,
                trigger="cron",
                hour=hh,
                minute=mm,
                kwargs={"patient_id": pid, "time_str": d["time"]},
                id=f"dose:{pid}:{d['time']}",
                replace_existing=True,
                coalesce=True,
                misfire_grace_time=300,
                max_instances=1,
            )

    # Daily measurement checks
    for p in PATIENTS:
        pid = p["patient_id"]
        for chk in p.get("measurement_checks", []):
            hh, mm = (int(x) for x in chk["time"].split(":"))
            sched.add_job(
                engine._job_measure_check,
                trigger="cron",
                hour=hh,
                minute=mm,
                kwargs={"patient_id": pid, "measure_id": chk["measure_id"]},
                id=f"measure:{pid}:{chk['measure_id']}",
                replace_existing=True,
                coalesce=True,
                misfire_grace_time=300,
                max_instances=1,
            )

    sched.start()
    return sched


async def main() -> None:
    logging.basicConfig(
        level=logging.INFO,
        format="%(asctime)s %(levelname)s %(name)s — %(message)s",
    )
    log = logging.getLogger("pillsbot.app")
    log.info("startup.begin " + f"timezone='{cfg.TIMEZONE}'")

    # Build engine FIRST with adapter=None to break circular dependency
    engine = ReminderEngine(cfg, adapter=None)

    # Build Telegram adapter and attach back to the engine
    bot_token = get_bot_token()
    patient_groups = [p["group_id"] for p in PATIENTS]
    adapter = TelegramAdapter(bot_token, engine=engine, patient_groups=patient_groups)
    engine.attach_adapter(adapter)

    # Initialize engine state
    await engine.start(scheduler=None)

    # Proper time-based scheduling
    await schedule_jobs(engine, timezone=cfg.TZ)

    log.info("startup.ready " + f"patients={len(PATIENTS)}")

    # Single polling loop
    await adapter.run_polling()


if __name__ == "__main__":
    asyncio.run(main())


### FILE: ./config.py
"""
Runtime configuration for PillsBot.
All times for scheduling/logging are Europe/Kyiv.
"""

from __future__ import annotations

import os
from typing import Any
from zoneinfo import ZoneInfo

# --------------------------------------------------------------------------------------
# Core bot settings
# --------------------------------------------------------------------------------------
BOT_TOKEN: str | None = (
    "550433191:AAFkG6atLs_uo0nwphtuiwbwIJeUhwfzCyI"  # fallback if env BOT_TOKEN is not set
)
TIMEZONE = "Europe/Kyiv"
TZ = ZoneInfo(TIMEZONE)

# Retry/escalation configuration
RETRY_INTERVAL_S = 30  # I
MAX_RETRY_ATTEMPTS = 3  # N
TAKING_GRACE_INTERVAL_S = 600  # pre-confirm grace period in seconds

# --------------------------------------------------------------------------------------
# Patterns (centralized: confirmations + measurements)
# --------------------------------------------------------------------------------------
# Confirmation patterns (search-anywhere). Existing behavior unchanged.
CONFIRM_PATTERNS = [
    r"[OoОо][KkКк]",
    r"\bok\b",
    r"\bок\b",
    r"\bтак\b",
    r"\bвже\b",
    r"\bда\b",
    r"\bокей\b",
    r"\bдобре\b",
    r"\+",
    r"^\s*(✅|✔️|👍)\s*$",
    r"\bdone\b",
]

# Measurement definitions (start-anchored; config-only extensibility)
MEASURES: dict[str, dict[str, Any]] = {
    "pressure": {
        "label": "Тиск",
        "patterns": ["тиск", "давление", "BP", "pressure"],
        "csv_file": "pillsbot/logs/pressure.csv",
        "parser_kind": "int3",  # exactly three integers
        "separators": [" ", ",", "/"],  # allowed separators between the three numbers
    },
    "weight": {
        "label": "Вага",
        "patterns": ["вага", "вес", "взвешивание", "weight"],
        "csv_file": "pillsbot/logs/weight.csv",
        "parser_kind": "float1",  # exactly one number
        "decimal_commas": True,  # accept "102,4"
    },
}

# --------------------------------------------------------------------------------------
# Logging
# --------------------------------------------------------------------------------------
# CSV outcome file (unchanged name for backward compatibility with tests/tools)
LOG_FILE = "pillsbot/logs/pills.csv"

# Human-readable audit trail (separate from CSV)
AUDIT_LOG_FILE = "pillsbot/logs/audit.log"

# --------------------------------------------------------------------------------------
# Patient roster (example/demo values; replace with real IDs)
# --------------------------------------------------------------------------------------
PATIENTS: list[dict[str, Any]] = [
    {
        "patient_id": 382163513,
        "patient_label": "Іван Петров",
        "group_id": -1002690368389,
        "nurse_user_id": 7391874317,
        "doses": [
            {"time": "17:43", "text": "Вітамін Д"},
            {"time": "20:00", "text": "Вітамін Д"},
        ],
        # Optional daily measurement checks (per measure)
        "measurement_checks": [
            {"measure_id": "pressure", "time": "21:00"},
            {"measure_id": "weight", "time": "21:00"},
        ],
    },
]


def get_bot_token() -> str:
    token = BOT_TOKEN or os.getenv("BOT_TOKEN")
    if not token:
        raise RuntimeError(
            "Bot token is not set. Set BOT_TOKEN in config.py or env var BOT_TOKEN."
        )
    return token


### FILE: ./core/config_validation.py
# pillsbot/core/config_validation.py
from __future__ import annotations

from datetime import datetime
from typing import Any
import os


def validate_config(cfg: Any) -> None:
    """
    Validate runtime configuration before starting the bot.

    - Ensures patient records have required fields.
    - Ensures dose times are valid HH:MM strings and unique per patient.
    - Ensures dose text is present.
    - Ensures measurement configuration (if present) is valid.
    """
    required_fields = {
        "patient_id",
        "patient_label",
        "group_id",
        "nurse_user_id",
        "doses",
    }

    def parse_time_str(t: str) -> None:
        try:
            datetime.strptime(t, "%H:%M")
        except ValueError as e:
            raise ValueError(f"Invalid time '{t}', expected HH:MM") from e

    patients = getattr(cfg, "PATIENTS", None)
    if not isinstance(patients, list):
        raise ValueError("PATIENTS must be a list of patient dictionaries")

    for p in patients:
        missing = required_fields - set(p.keys())
        if missing:
            raise ValueError(f"Patient missing fields: {missing}")

        seen_times = set()
        for d in p.get("doses", []):
            t = d.get("time")
            if not t:
                raise ValueError(
                    f"Missing 'time' in a dose for patient {p.get('patient_label')}"
                )
            if t in seen_times:
                raise ValueError(
                    f"Duplicate dose time for patient {p['patient_label']}: {t}"
                )
            seen_times.add(t)
            parse_time_str(t)

            if not d.get("text"):
                raise ValueError(
                    f"Dose text is required for patient {p['patient_label']} at {t}"
                )

        # Validate optional measurement checks
        checks = p.get("measurement_checks", []) or []
        per_measure_seen: dict[str, set[str]] = {}
        for chk in checks:
            mid = chk.get("measure_id")
            if not mid:
                raise ValueError(
                    f"measurement_checks entry missing 'measure_id' for patient {p['patient_label']}"
                )
            measures = getattr(cfg, "MEASURES", {})
            if mid not in measures:
                raise ValueError(
                    f"Unknown measure_id '{mid}' in measurement_checks for patient {p['patient_label']}"
                )
            t = chk.get("time")
            if not t:
                raise ValueError(
                    f"measurement_checks entry missing 'time' for measure {mid} and patient {p['patient_label']}"
                )
            parse_time_str(t)
            seen = per_measure_seen.setdefault(mid, set())
            if t in seen:
                raise ValueError(
                    f"Duplicate measurement check time for measure {mid} and patient {p['patient_label']}: {t}"
                )
            seen.add(t)

    # Ensure directories for measurement CSVs exist
    for _, m in (getattr(cfg, "MEASURES", {}) or {}).items():
        path = m.get("csv_file")
        if path:
            os.makedirs(os.path.dirname(path), exist_ok=True)


### FILE: ./core/i18n.py
from __future__ import annotations

MESSAGES = {
    # v1 pill-reminder texts (unchanged)
    "reminder": "час прийняти {pill_text}",
    "repeat_reminder": "не отримано підтвердження",
    "confirm_ack": "підтвердження прийнято, дякую",
    "preconfirm_ack": "заздалегідь - теж ОК. Дякую",
    "too_early": "ще не на часі, чекайте нагадування",
    "escalate_group": "не отримано підтвердження, залучаємо мед.сестру",
    "escalate_dm": "пацієнт ({patient_label}): пропустив {date} {time}, {pill_text}",
    # v2 measurement acks/errors + daily check
    "measure_ack": "отримано показник {measure_label}. Все ок.",
    "measure_error_arity": "вибачте, помилка. має бути {expected} числа",
    "measure_error_one": "вибачте, помилка. має бути 1 число",
    "measure_unknown": "вибачте, помилка. невідомий показник",
    "measure_missing_today": "сьогодні не отримано показник {measure_label}",
    # v3 buttons / prompts / help
    "btn_pressure": "Тиск",
    "btn_weight": "Вага",
    "btn_help": "Help",
    "btn_confirm_taken": "Ліки вже прийнято",
    "prompt_pressure": 'Введіть три числа: систолічний, діастолічний, пульс. Приклад: "тиск 120 80 60".',
    "prompt_weight": 'Введіть одну цифру (кг). Приклад: "вага 72,5".',
    "help_brief": (
        "Кнопки:\n"
        '• Тиск — надішліть 3 числа: верхній, нижній, пульс (наприклад: "тиск 120 80 60").\n'
        '• Вага — надішліть одне число в кг (наприклад: "вага 72,5").\n'
        "• Ліки вже прийнято — підтвердження прийому.\n"
        'Також можна просто написати: "ок", "+", "так" тощо.'
    ),
    # v3 callback responses / guards
    "cb_only_patient": "Ця кнопка — лише для пацієнта.",
    "cb_already_done": "Це нагадування вже підтверджено. Дякую!",
    "cb_late_ok": "Підтверджено. Дякую!",
    "cb_no_target": "Немає активного нагадування.",
}


def fmt(key: str, **kwargs) -> str:
    return MESSAGES[key].format(**kwargs)


### FILE: ./core/logging_utils.py
# pillsbot/core/logging_utils.py
from __future__ import annotations

import logging
import os
from logging.handlers import RotatingFileHandler
from typing import Any

LOG_FORMAT = "%(asctime)s %(levelname)s %(name)s — %(message)s"
DATE_FORMAT = "%Y-%m-%d %H:%M:%S"


def setup_logging(cfg: Any) -> logging.Logger:
    """
    Configure logging:
    - Console shows INFO and above (clean runtime output).
    - Audit log file stores DEBUG and above (full trace).
    """
    log_dir = os.path.dirname(cfg.AUDIT_LOG_FILE)
    if log_dir:
        os.makedirs(log_dir, exist_ok=True)

    root = logging.getLogger("pillsbot")
    root.setLevel(logging.DEBUG)  # Allow DEBUG to propagate to file handler

    fmt = logging.Formatter(LOG_FORMAT, DATE_FORMAT)

    # File handler — DEBUG level, full history
    fh = RotatingFileHandler(
        cfg.AUDIT_LOG_FILE, maxBytes=1_000_000, backupCount=10, encoding="utf-8"
    )
    fh.setFormatter(fmt)
    fh.setLevel(logging.DEBUG)

    # Console handler — INFO level, clean output
    ch = logging.StreamHandler()
    ch.setFormatter(fmt)
    ch.setLevel(logging.INFO)

    root.handlers.clear()
    root.addHandler(fh)
    root.addHandler(ch)

    return root


def kv(**kwargs: Any) -> str:
    """Key=value compact formatting (values repr()'d for clarity)."""
    return " ".join(f"{k}={v!r}" for k, v in kwargs.items())


### FILE: ./core/matcher.py
# pillsbot/core/matcher.py
from __future__ import annotations

import re
from typing import Iterable, List, Pattern


class Matcher:
    """
    Regex-based confirmation matcher (Unicode + case-insensitive).
    All matching semantics live in the provided patterns (see config.CONFIRM_PATTERNS).
    No input normalization or pattern rewriting happens here.
    """

    def __init__(self, patterns: Iterable[str]) -> None:
        flags = re.IGNORECASE | re.UNICODE
        self._compiled: List[Pattern[str]] = [re.compile(p, flags) for p in patterns]

    def matches_confirmation(self, text: str | None) -> bool:
        if not text:
            return False
        return any(rx.search(text) for rx in self._compiled)


__all__ = ["Matcher"]


### FILE: ./core/measurements.py
# pillsbot/core/measurements.py
from __future__ import annotations

import os
import re
from dataclasses import dataclass
from datetime import datetime, date
from typing import Any, Dict, List, Optional, Tuple


@dataclass
class MeasureDef:
    id: str
    label: str
    patterns: List[str]
    csv_file: str
    parser_kind: str  # "int3" | "float1"
    separators: Optional[List[str]] = None  # for pressure
    decimal_commas: Optional[bool] = None  # for weight


class MeasurementRegistry:
    """
    Central registry for measurement parsing + storage.

    * Start-anchored dispatch by configured patterns.
    * Optional punctuation after keyword (':' or '-') is allowed.
    * Per-measure syntax validation/parsing.
    * CSV append with header creation.
    * 'has_today' helper for daily checks.
    """

    def __init__(self, tz, measures_cfg: Dict[str, Dict[str, Any]] | None = None):
        self.tz = tz
        self.measures: Dict[str, MeasureDef] = {}
        self._compiled: Dict[str, re.Pattern[str]] = {}
        measures_cfg = measures_cfg or {}
        flags = re.IGNORECASE | re.UNICODE

        for mid, m in measures_cfg.items():
            md = MeasureDef(
                id=mid,
                label=m["label"],
                patterns=m["patterns"],
                csv_file=m["csv_file"],
                parser_kind=m["parser_kind"],
                separators=m.get("separators"),
                decimal_commas=m.get("decimal_commas"),
            )
            self.measures[mid] = md
            # ^\s*(kw1|kw2|...)\b[:\-]?\s*(?P<body>.*)?$
            union = "|".join(re.escape(p) for p in md.patterns)
            self._compiled[mid] = re.compile(
                rf"^\s*(?:{union})\b[:\-]?\s*(?P<body>.+)?$", flags
            )

    def available(self) -> List[str]:
        return list(self.measures.keys())

    def get_label(self, measure_id: str) -> str:
        return self.measures[measure_id].label

    # ---- Dispatch (start-anchored) ----
    def match(self, text: str | None) -> Optional[Tuple[str, str]]:
        t = text or ""
        for mid, rx in self._compiled.items():
            m = rx.match(t)
            if m:
                body = (m.group("body") or "").strip()
                return mid, body
        return None

    # ---- Parsing per measure ----
    def parse(self, measure_id: str, body: str) -> Dict[str, Any]:
        md = self.measures[measure_id]
        if md.parser_kind == "int3":
            # pressure: exactly three integers; separators: space/comma/slash
            seps = md.separators or [" ", ",", "/"]
            s = body.strip()
            if not s:
                return {"ok": False, "error": "arity"}
            for sep in seps:
                s = s.replace(sep, " ")
            parts = [p for p in s.strip().split() if p]
            if len(parts) != 3:
                return {"ok": False, "error": "arity"}
            vals: List[int] = []
            for p in parts:
                if p.startswith("+"):
                    p = p[1:]
                if not p.isdigit():
                    return {"ok": False, "error": "format"}
                vals.append(int(p))
            return {"ok": True, "values": tuple(vals)}
        elif md.parser_kind == "float1":
            # weight: exactly one number (dot or comma decimal), non-negative
            tok = (body or "").strip()
            toks = tok.split()
            if len(toks) != 1:
                return {"ok": False, "error": "arity_one"}
            token = toks[0]
            if md.decimal_commas:
                token = token.replace(",", ".")
            if token.startswith("+"):
                token = token[1:]
            try:
                v = float(token)
            except ValueError:
                return {"ok": False, "error": "format_one"}
            if v < 0 or v != v or v in (float("inf"), float("-inf")):
                return {"ok": False, "error": "format_one"}
            return {"ok": True, "values": (v,)}
        else:
            raise ValueError(f"Unknown parser_kind for {measure_id}: {md.parser_kind}")

    # ---- CSV writing ----
    def append_csv(
        self,
        measure_id: str,
        dt_local: datetime,
        patient_id: int,
        patient_label: str,
        values: tuple,
    ) -> None:
        md = self.measures[measure_id]
        path = md.csv_file
        os.makedirs(os.path.dirname(path), exist_ok=True)
        is_new = not os.path.exists(path)

        with open(path, "a", encoding="utf-8") as f:
            if is_new:
                if measure_id == "pressure":
                    f.write(
                        "date_time_local,patient_id,patient_label,systolic,diastolic,pulse\n"
                    )
                elif measure_id == "weight":
                    f.write("date_time_local,patient_id,patient_label,weight\n")
                else:
                    cols = ",".join(f"value{i + 1}" for i in range(len(values)))
                    f.write(f"date_time_local,patient_id,patient_label,{cols}\n")

            ts = dt_local.strftime("%Y-%m-%d %H:%M")
            if measure_id == "pressure":
                sys, dia, pul = values
                f.write(f"{ts},{patient_id},{patient_label},{sys},{dia},{pul}\n")
            elif measure_id == "weight":
                (w,) = values
                f.write(f"{ts},{patient_id},{patient_label},{w}\n")
            else:
                vals = ",".join(str(x) for x in values)
                f.write(f"{ts},{patient_id},{patient_label},{vals}\n")

    # ---- Daily check helper ----
    def has_today(self, measure_id: str, patient_id: int, date_local: date) -> bool:
        md = self.measures[measure_id]
        path = md.csv_file
        if not os.path.exists(path):
            return False
        with open(path, "r", encoding="utf-8") as f:
            _ = f.readline()  # header
            for line in f:
                line = line.strip()
                if not line:
                    continue
                parts = line.split(",")
                if len(parts) < 3:
                    continue
                dt_str = parts[0].strip()
                pid_str = parts[1].strip()
                try:
                    dt = datetime.strptime(dt_str, "%Y-%m-%d %H:%M")
                    pid = int(pid_str)
                except Exception:
                    continue
                if pid == patient_id and dt.date() == date_local:
                    return True
        return False


### FILE: ./core/reminder_engine.py
# pillsbot/core/reminder_engine.py
from __future__ import annotations

import asyncio
import contextlib
import logging
from dataclasses import dataclass
from datetime import datetime, timedelta
from typing import Any, Optional, Dict
from zoneinfo import ZoneInfo

from pillsbot.core.matcher import Matcher
from pillsbot.core.i18n import fmt, MESSAGES
from pillsbot.core.logging_utils import kv
from pillsbot.core.measurements import MeasurementRegistry
from pillsbot.core.reminder_state import (
    Clock,
    Status,
    DoseKey,
    DoseInstance,
    ReminderState,
)
from pillsbot.core.reminder_messaging import ReminderMessenger
from pillsbot.core.reminder_retry import RetryManager


# -------------------------------------------------------------------------------------------------
# Public inbound message type (kept here for backwards-compat imports in tests)
# -------------------------------------------------------------------------------------------------
@dataclass
class IncomingMessage:
    group_id: int
    sender_user_id: int
    text: str
    sent_at_utc: datetime


class ReminderEngine:
    """
    Orchestrates reminder jobs, callback resolution, and state transitions.
    Messaging (UI/Telegram) and retry timing are delegated to dedicated modules.
    Public API remains compatible with the original tests/specs.
    """

    # ---- lifecycle -------------------------------------------------------------------
    def __init__(self, config: Any, adapter: Any | None, clock: Optional[Clock] = None):
        self.cfg = config
        self.adapter = adapter
        tz = getattr(config, "TZ", None) or ZoneInfo(
            getattr(config, "TIMEZONE", "Europe/Kyiv")
        )
        self.clock = clock or Clock(tz)

        # Core services
        self.matcher = Matcher(getattr(config, "CONFIRM_PATTERNS", []))
        self.measures = MeasurementRegistry(tz, getattr(config, "MEASURES", None))
        self.log = logging.getLogger("pillsbot.engine")

        # State & messaging
        self.state_mgr = ReminderState(tz, self.clock)
        self.messenger = ReminderMessenger(
            adapter=self.adapter,
            log=self.log,
            inline_confirm_enabled=getattr(self.cfg, "INLINE_CONFIRM_ENABLED", True),
        )
        # msg_id → DoseKey (for robust inline callback resolution)
        self._msg_to_key: Dict[int, DoseKey] = {}

        # Index lookups
        self.patient_index: Dict[int, dict] = {}  # patient_id → patient dict
        self.group_to_patient: Dict[int, int] = {}  # group_id → patient_id

        # Retry manager wiring (interval/max read from cfg at start time)
        self.retry_mgr: Optional[RetryManager] = None

    def attach_adapter(self, adapter: Any) -> None:
        """
        Attach/replace the transport adapter after construction (solves circular init).
        Ensures the messenger uses the same adapter instance.
        """
        self.adapter = adapter
        self.messenger.adapter = adapter
        self.log.debug("engine.adapter.attached " + kv(kind=type(adapter).__name__))

    async def start(self, scheduler: Any | None) -> None:
        """Prepare indices/state; optionally register jobs with an external scheduler."""
        # Build indices
        for p in getattr(self.cfg, "PATIENTS", []):
            pid = p["patient_id"]
            self.patient_index[pid] = p
            self.group_to_patient[p["group_id"]] = pid
            self.state_mgr.ensure_today_instances(p)

        # Wire retry with current config
        self.retry_mgr = RetryManager(
            interval_seconds=int(getattr(self.cfg, "RETRY_INTERVAL_S", 30)),
            max_attempts=int(getattr(self.cfg, "MAX_RETRY_ATTEMPTS", 3)),
            send_repeat=self._send_repeat_wrapper,
            on_escalate=self._on_escalate_wrapper,
            set_status=self.state_mgr.set_status,
            get_status=self.state_mgr.status,
            logger=self.log,
        )

        # Optionally register jobs with an external scheduler
        if scheduler is not None:
            try:
                for p in getattr(self.cfg, "PATIENTS", []):
                    for d in p["doses"]:
                        scheduler.add_job(
                            self._start_dose_job,
                            kwargs={
                                "patient_id": p["patient_id"],
                                "time_str": d["time"],
                            },
                        )
                    for chk in p.get("measurement_checks", []):
                        scheduler.add_job(
                            self._job_measure_check,
                            kwargs={
                                "patient_id": p["patient_id"],
                                "measure_id": chk["measure_id"],
                            },
                        )
            except Exception:
                # Non-fatal if the provided scheduler doesn't support add_job
                pass

    # ---- incoming from adapter --------------------------------------------------------
    async def on_patient_message(self, msg: IncomingMessage) -> None:
        """Main entry for any text from the patient's group."""
        self.log.info(
            "msg.engine.in "
            + kv(
                group_id=msg.group_id,
                sender_user_id=msg.sender_user_id,
                text=(msg.text or ""),
            )
        )

        pid = self.group_to_patient.get(msg.group_id)
        if pid is None or pid != msg.sender_user_id:
            self.log.debug(
                "msg.engine.reject "
                + kv(
                    reason="unauthorized or unknown group",
                    group_id=msg.group_id,
                    sender_user_id=msg.sender_user_id,
                )
            )
            return

        patient = self.patient_index[pid]
        text = (msg.text or "").strip()
        low = text.lower()

        # Quick actions via patient keyboard
        if low == MESSAGES["btn_pressure"].lower():
            await self._prompt(patient["group_id"], "prompt_pressure", patient=patient)
            return
        if low == MESSAGES["btn_weight"].lower():
            await self._prompt(patient["group_id"], "prompt_weight", patient=patient)
            return
        if low == MESSAGES["btn_help"].lower():
            await self._reply(patient["group_id"], "help_brief", with_fixed_kb=patient)
            return

        # Measurements: anchored dispatch
        mm = self.measures.match(text)
        if mm:
            mid, body = mm
            parsed = self.measures.parse(mid, body)
            if parsed.get("ok"):
                now_local = self.clock.now()
                self.measures.append_csv(
                    mid, now_local, pid, patient["patient_label"], parsed["values"]
                )
                await self._reply(
                    patient["group_id"],
                    "measure_ack",
                    with_fixed_kb=patient,
                    measure_label=self.measures.get_label(mid),
                )
            else:
                key = (
                    "measure_error_arity"
                    if parsed.get("error") in ("arity", "arity_one")
                    else (
                        "measure_error_one"
                        if parsed.get("error") == "arity_one"
                        else "measure_unknown"
                    )
                )
                await self._reply(patient["group_id"], key, with_fixed_kb=patient)
            return

        # Confirmation via regex patterns
        if self.matcher.matches_confirmation(text):
            await self._handle_confirmation_text(patient)
            return

        # Fallback for unknown input: explicitly say "unknown measure"
        # (tests expect "невідомий показник" to be sent)
        await self._reply(patient["group_id"], "measure_unknown", with_fixed_kb=patient)

    # ---- inline button callback from adapter ------------------------------------------
    async def on_inline_confirm(
        self,
        *,
        group_id: int,
        from_user_id: int,
        data: str,
        message_id: Optional[int] = None,
    ) -> dict:
        """
        Inline button confirm.
        Returns dict for adapter: {'cb_text': str|None, 'show_alert': bool}.
        Resolution order: message_id → payload → selection today.
        """
        expected_pid = self.group_to_patient.get(group_id)
        if expected_pid is None or from_user_id != expected_pid:
            return {"cb_text": fmt("cb_only_patient"), "show_alert": False}

        inst: Optional[DoseInstance] = None

        # 1) Resolve by message_id (authoritative mapping)
        if message_id is not None:
            key = self._msg_to_key.get(message_id)
            if key:
                inst = self.state_mgr.get(key)

        # 2) Parse payload
        if inst is None and data.startswith("confirm:"):
            try:
                _, pid_s, date_s, time_s = data.split(":")
                key = DoseKey(int(pid_s), date_s, time_s)
                inst = self.state_mgr.get(key)
            except Exception:
                pass

        # 3) Fallback: any awaiting/nearest today for this patient
        if inst is None:
            patient = self.patient_index.get(expected_pid)
            if patient:
                inst = self.state_mgr.select_target_for_confirmation(
                    self.clock.now(), patient
                )

        if not inst:
            return {"cb_text": fmt("cb_no_target"), "show_alert": False}

        # Idempotent confirm
        if self.state_mgr.status(inst) == Status.CONFIRMED:
            return {"cb_text": fmt("cb_already_done"), "show_alert": False}

        await self._confirm_and_finalize(inst, source="inline")
        return {"cb_text": fmt("cb_late_ok"), "show_alert": False}

    # ---- jobs / orchestration ----------------------------------------------------------
    async def _start_dose_job(self, *, patient_id: int, time_str: str) -> None:
        """Scheduler entrypoint for a planned dose."""
        patient = self.patient_index.get(patient_id)
        if not patient:
            self.log.debug(
                "job.trigger.miss "
                + kv(reason="unknown patient", patient_id=patient_id)
            )
            return

        key = DoseKey(patient_id, self.clock.today_str(), time_str)
        inst = self.state_mgr.get(key)
        if inst is None:
            # Ensure exists
            self.state_mgr.ensure_today_instances(patient)
            inst = self.state_mgr.get(key)
            if inst is None:
                self.log.error(
                    "job.trigger.miss "
                    + kv(
                        patient_id=patient_id, time=time_str, reason="state not created"
                    )
                )
                return

        if self.state_mgr.status(inst) == Status.CONFIRMED:
            self.log.debug(
                "job.trigger.skip "
                + kv(patient_id=patient_id, time=time_str, reason="already confirmed")
            )
            return

        # Pre-set awaiting FIRST to eliminate tap-before-set race
        self.state_mgr.set_status(inst, Status.AWAITING)
        inst.attempts_sent = 1

        msg_id = await self.messenger.send_reminder(inst, "reminder")
        if msg_id is not None:
            inst.last_message_ids.append(msg_id)
            self._msg_to_key[msg_id] = inst.dose_key

        await self.messenger.refresh_reply_keyboard(patient)
        await self._start_retry(inst)

    # Back-compat alias expected by tests: _measurement_check_job(pid, measure_id)
    async def _measurement_check_job(self, patient_id: int, measure_id: str) -> None:
        await self._job_measure_check(patient_id=patient_id, measure_id=measure_id)

    async def _job_measure_check(self, *, patient_id: int, measure_id: str) -> None:
        """Daily 'missing today' measurement check."""
        patient = self.patient_index.get(patient_id)
        if not patient:
            return
        today = self.clock.now().date()
        if not self.measures.has_today(measure_id, patient_id, today):
            await self._reply(
                patient["group_id"],
                "measure_missing_today",
                with_fixed_kb=patient,
                measure_label=self.measures.get_label(measure_id),
            )

    # ---- retry glue -------------------------------------------------------------------
    async def _start_retry(self, inst: DoseInstance) -> None:
        """Start/replace retry loop task for the given instance."""
        if self.retry_mgr is None:
            return
        await self._stop_retry(inst)  # replace if already running
        inst.retry_task = asyncio.create_task(self.retry_mgr.run(inst))

    async def _stop_retry(self, inst: DoseInstance) -> None:
        t = inst.retry_task
        if t and not t.done():
            t.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await t
        inst.retry_task = None

    async def _send_repeat_wrapper(self, inst: DoseInstance) -> None:
        msg_id = await self.messenger.send_reminder(inst, "repeat")
        if msg_id is not None:
            inst.last_message_ids.append(msg_id)
            self._msg_to_key[msg_id] = inst.dose_key

    async def _on_escalate_wrapper(self, inst: DoseInstance) -> None:
        await self.messenger.send_escalation(inst)
        self._log_outcome_csv(inst, "escalated")

    # ---- confirmation handling ---------------------------------------------------------
    async def _handle_confirmation_text(self, patient: dict) -> None:
        """Text-based confirm; supports preconfirm within grace window."""
        now = self.clock.now()
        target = self.state_mgr.select_target_for_confirmation(now, patient)
        if not target:
            await self._reply(patient["group_id"], "too_early", with_fixed_kb=patient)
            return

        # If pre-confirm within grace interval, confirm immediately with the special ack
        grace_s = int(getattr(self.cfg, "TAKING_GRACE_INTERVAL_S", 600))
        if (
            target.scheduled_dt_local - now <= timedelta(seconds=grace_s)
            and self.state_mgr.status(target) != Status.AWAITING
        ):
            target.preconfirmed = True
            await self._confirm_and_finalize(target, source="preconfirm")
            await self._reply(
                patient["group_id"], "preconfirm_ack", with_fixed_kb=patient
            )
            return

        await self._confirm_and_finalize(target, source="text")
        await self._reply(patient["group_id"], "confirm_ack", with_fixed_kb=patient)

    async def _confirm_and_finalize(self, inst: DoseInstance, *, source: str) -> None:
        """Persistently mark confirmed, stop retry/escalation, and write outcome row."""
        if self.state_mgr.status(inst) == Status.CONFIRMED:
            return
        self.state_mgr.set_status(inst, Status.CONFIRMED)
        await self._stop_retry(inst)
        self.log.info(
            "dose.confirm "
            + kv(patient_id=inst.patient_id, time=inst.dose_key.time_str, source=source)
        )
        self._log_outcome_csv(inst, "confirmed")

    # ---- messaging shims (keep engine free of Telegram specifics) ---------------------
    async def _reply(
        self,
        group_id: int,
        template_key: str,
        *,
        with_fixed_kb: Optional[dict] = None,
        **fmt_args: Any,
    ) -> Optional[int]:
        """Send a group message using i18n template; optionally attach fixed reply kb."""
        msg_id = await self.messenger.send_group_template(
            group_id, template_key, **fmt_args
        )
        if with_fixed_kb is not None:
            await self.messenger.refresh_reply_keyboard(with_fixed_kb)
        return msg_id

    async def _prompt(self, group_id: int, template_key: str, *, patient: dict) -> None:
        """Send a small prompt and surface the ForceReply/keyboard if available."""
        await self._reply(group_id, template_key, with_fixed_kb=patient)

    # ---- tiny sugar -------------------------------------------------------------------
    def _today_str(self) -> str:
        return self.clock.today_str()

    # ---- outcome CSV ------------------------------------------------------------------
    def _log_outcome_csv(self, inst: DoseInstance, status: str) -> None:
        """Append a one-line outcome row into the configured CSV (analytics/audit)."""
        line = (
            f"{inst.scheduled_dt_local.strftime('%Y-%m-%d %H:%M')}, "
            f"{inst.patient_id}, {inst.patient_label}, {inst.pill_text}, {status}, {inst.attempts_sent}\n"
        )
        path = getattr(self.cfg, "LOG_FILE", "pillsbot/logs/pills.csv")
        import os

        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "a", encoding="utf-8") as f:
            f.write(line)

    # ---- backwards-compat for tests ---------------------------------------------------
    @property
    def state(self):
        """Expose the raw state mapping for test compatibility."""
        return self.state_mgr.mapping


# Re-export for backwards compatibility
__all__ = ["ReminderEngine", "IncomingMessage", "Status", "DoseKey", "DoseInstance"]


### FILE: ./core/reminder_messaging.py
# pillsbot/core/reminder_messaging.py
from __future__ import annotations

import logging
from typing import Any, Optional

from pillsbot.core.i18n import fmt, MESSAGES
from pillsbot.core.logging_utils import kv
from pillsbot.core.reminder_state import DoseKey, DoseInstance

# Telegram-only types are optional; keep them encapsulated here.
try:
    from aiogram.types import (
        ReplyKeyboardMarkup,
        KeyboardButton,
        InlineKeyboardMarkup,
        InlineKeyboardButton,
        ForceReply,
    )
except Exception:  # pragma: no cover - optional dependency
    ReplyKeyboardMarkup = KeyboardButton = InlineKeyboardMarkup = (
        InlineKeyboardButton
    ) = ForceReply = None


class ReminderMessenger:
    """
    Handles all outbound UX: text templates, keyboards, inline buttons, and fallbacks.
    Engine calls this via simple methods and stays transport-agnostic.
    """

    def __init__(
        self,
        adapter: Any | None,
        log: logging.Logger,
        inline_confirm_enabled: bool = True,
    ):
        self.adapter = adapter
        self.log = log
        self.inline_confirm_enabled = inline_confirm_enabled

    # -- high-level helpers -------------------------------------------------------------
    async def send_reminder(
        self, inst: DoseInstance, template_key: str
    ) -> Optional[int]:
        """Send reminder/retry message; attach inline 'Confirm Taken' when enabled."""
        kb_inline = (
            self.build_confirm_inline_kb(inst.dose_key)
            if self.inline_confirm_enabled and self._has_telegram()
            else None
        )
        text = (
            fmt("reminder", pill_text=inst.pill_text)
            if template_key == "reminder"
            else fmt("repeat_reminder")
        )
        return await self._send_group(inst.group_id, text, reply_markup=kb_inline)

    async def send_group_template(
        self, group_id: int, template_key: str, **fmt_args: Any
    ) -> Optional[int]:
        """Send a plain templated group message (no buttons)."""
        text = fmt(template_key, **fmt_args)
        return await self._send_group(group_id, text, reply_markup=None)

    async def refresh_reply_keyboard(self, patient: dict) -> Optional[int]:
        """
        Refresh the fixed reply keyboard. Uses a visible text to make clients keep it.
        Always sets selective=True (your environment is a small private group).
        """
        if not self._has_telegram() or self.adapter is None:
            self.log.error(
                "keyboard.refresh.skip " + kv(reason="adapter or telegram missing")
            )
            return None
        try:
            kb = self.build_patient_reply_kb(patient, selective=True)
            msg_id = await self._send_group(
                patient["group_id"], "Оновив кнопки ↓", reply_markup=kb
            )
            return msg_id
        except Exception as e:  # pragma: no cover - adapter-level errors
            self.log.error(
                "keyboard.refresh.error "
                + kv(group_id=patient.get("group_id"), err=str(e))
            )
            return None

    async def send_escalation(self, inst: DoseInstance) -> None:
        """Group notice + DM to nurse."""
        await self._send_group(inst.group_id, MESSAGES["escalate_group"])
        await self._send_nurse_dm(
            inst.nurse_user_id,
            fmt(
                "escalate_dm",
                patient_label=inst.patient_label,
                date=inst.dose_key.date_str,
                time=inst.dose_key.time_str,
                pill_text=inst.pill_text,
            ),
        )

    # -- low-level adapter calls with fallbacks -----------------------------------------
    async def _send_group(
        self, group_id: int, text: str, reply_markup: Any | None = None
    ) -> Optional[int]:
        """
        Adapter compatibility: prefer (group_id, text, reply_markup); fallback to (group_id, text).
        Returns message_id when the adapter provides it; else None.
        """
        if self.adapter is None:
            self.log.error(
                "msg.out.group.error "
                + kv(group_id=group_id, err="adapter not attached")
            )
            return None

        try:
            self.log.info(
                "msg.out.group "
                + kv(
                    group_id=group_id, text=text[:64] + ("…" if len(text) > 64 else "")
                )
            )
            try:
                # preferred signature
                msg = await self.adapter.send_group_message(
                    group_id, text, reply_markup=reply_markup
                )  # type: ignore
                return getattr(msg, "message_id", None)
            except TypeError:
                # fallback signature (tests use this)
                _ = await self.adapter.send_group_message(group_id, text)  # type: ignore
                return None
        except Exception as e:  # pragma: no cover - adapter-level errors
            self.log.error("msg.out.group.error " + kv(group_id=group_id, err=str(e)))
            return None

    async def _send_nurse_dm(self, user_id: int, text: str) -> None:
        if self.adapter is None:
            self.log.error(
                "msg.out.dm.error " + kv(user_id=user_id, err="adapter not attached")
            )
            return
        try:
            self.log.info(
                "msg.out.dm "
                + kv(user_id=user_id, text=text[:64] + ("…" if len(text) > 64 else ""))
            )
            await self.adapter.send_nurse_dm(user_id, text)
        except Exception as e:  # pragma: no cover
            self.log.error("msg.out.dm.error " + kv(user_id=user_id, err=str(e)))

    # -- Telegram UI builders (encapsulated here) ---------------------------------------
    def _has_telegram(self) -> bool:
        return InlineKeyboardMarkup is not None

    def build_patient_reply_kb(
        self, patient: dict, *, selective: bool = True
    ) -> Any | None:
        """
        Persistent patient keyboard; selective=True so only the patient sees it.
        Kept here to isolate Telegram-specifics from the engine.
        """
        if ReplyKeyboardMarkup is None:  # non-Telegram channels
            return None
        return ReplyKeyboardMarkup(
            keyboard=[
                [
                    KeyboardButton(text=MESSAGES["btn_pressure"]),
                    KeyboardButton(text=MESSAGES["btn_weight"]),
                ],
                [KeyboardButton(text=MESSAGES["btn_help"])],
            ],
            resize_keyboard=True,
            one_time_keyboard=False,
            is_persistent=True,
            selective=selective,
            input_field_placeholder="Виберіть дію або введіть значення…",
        )

    def build_confirm_inline_kb(self, dose_key: DoseKey) -> Any | None:
        """Inline 'confirm taken' button attached to reminder/retry messages."""
        if InlineKeyboardMarkup is None:
            return None
        data = f"confirm:{dose_key.patient_id}:{dose_key.date_str}:{dose_key.time_str}"
        return InlineKeyboardMarkup(
            inline_keyboard=[
                [
                    InlineKeyboardButton(
                        text=MESSAGES["btn_confirm_taken"], callback_data=data
                    )
                ]
            ]
        )

    def build_force_reply(self) -> Any | None:
        """Guided input; selective=True for the patient."""
        if ForceReply is None:
            return None
        return ForceReply(selective=True)


### FILE: ./core/reminder_retry.py
# pillsbot/core/reminder_retry.py
from __future__ import annotations

import asyncio
from typing import Callable, Awaitable
from pillsbot.core.logging_utils import kv
from pillsbot.core.reminder_state import Status, DoseInstance


class RetryManager:
    """
    Runs the retry loop for a DoseInstance, escalating at the end.
    Keeps all timing policy here so engines stay small and testable.
    """

    def __init__(
        self,
        interval_seconds: int,
        max_attempts: int,
        *,
        send_repeat: Callable[[DoseInstance], Awaitable[None]],
        on_escalate: Callable[[DoseInstance], Awaitable[None]],
        set_status: Callable[[DoseInstance, Status], None],
        get_status: Callable[[DoseInstance], Status],
        logger,
    ) -> None:
        self.interval_seconds = interval_seconds
        self.max_attempts = max_attempts
        self.send_repeat = send_repeat
        self.on_escalate = on_escalate
        self.set_status = set_status
        self.get_status = get_status
        self.log = logger

    async def run(self, inst: DoseInstance) -> None:
        """
        Retry until confirmed or attempts exhausted. On exhaustion, escalate.
        Caller is responsible for storing/ cancelling the created task.
        """
        try:
            while self.get_status(inst) not in (Status.CONFIRMED, Status.ESCALATED):
                # Wait for the configured interval
                await asyncio.sleep(self.interval_seconds)

                # Maybe user confirmed in the meantime
                if self.get_status(inst) in (Status.CONFIRMED, Status.ESCALATED):
                    break

                # Attempt another reminder
                inst.attempts_sent += 1
                if inst.attempts_sent > self.max_attempts:
                    # Escalate
                    self.set_status(inst, Status.ESCALATED)
                    self.log.info(
                        "retry.escalate "
                        + kv(
                            patient_id=inst.patient_id,
                            time=inst.dose_key.time_str,
                            attempts=inst.attempts_sent,
                        )
                    )
                    await self.on_escalate(inst)
                    break

                self.log.debug(
                    "retry.repeat "
                    + kv(
                        patient_id=inst.patient_id,
                        time=inst.dose_key.time_str,
                        attempt=inst.attempts_sent,
                    )
                )
                await self.send_repeat(inst)
        except asyncio.CancelledError:  # normal shutdown path
            raise
        except Exception as e:  # pragma: no cover - defensive
            self.log.error(
                "retry.loop.error "
                + kv(
                    patient_id=inst.patient_id, time=inst.dose_key.time_str, err=str(e)
                )
            )


### FILE: ./core/reminder_state.py
# pillsbot/core/reminder_state.py
from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Optional, Tuple, Iterable
from zoneinfo import ZoneInfo


class Status(str, Enum):
    PENDING = "pending"
    AWAITING = "awaiting"
    CONFIRMED = "confirmed"
    ESCALATED = "escalated"


@dataclass(frozen=True)
class DoseKey:
    """Stable identity for a single scheduled dose."""

    patient_id: int
    date_str: str  # YYYY-MM-DD (engine-local date string)
    time_str: str  # HH:MM


@dataclass
class DoseInstance:
    """Mutable runtime state for a scheduled dose occurrence."""

    dose_key: DoseKey
    patient_id: int
    patient_label: str
    group_id: int
    nurse_user_id: int
    pill_text: str
    scheduled_dt_local: datetime
    status: str = Status.PENDING.value
    attempts_sent: int = 0
    preconfirmed: bool = False
    retry_task: Optional[asyncio.Task] = None
    last_message_ids: list[int] = field(default_factory=list)  # debug/trace only


class Clock:
    """Injectable, testable clock bound to a timezone."""

    def __init__(self, tz: ZoneInfo):
        self.tz = tz

    def now(self) -> datetime:
        return datetime.now(self.tz)

    def today_str(self) -> str:
        return self.now().strftime("%Y-%m-%d")


class ReminderState:
    """
    Owns the in-memory state and selection logic.
    Only manipulates DoseInstance objects; orchestration lives in the engine.
    """

    def __init__(self, tz: ZoneInfo, clock: Clock):
        self.tz = tz
        self.clock = clock
        self._state: Dict[DoseKey, DoseInstance] = {}

    # -- dict-like read access for compatibility with existing tests --
    def get(self, key: DoseKey) -> Optional[DoseInstance]:
        return self._state.get(key)

    def values(self) -> Iterable[DoseInstance]:
        return self._state.values()

    def keys(self) -> Iterable[DoseKey]:
        return self._state.keys()

    @property
    def mapping(self) -> Dict[DoseKey, DoseInstance]:
        """Expose the raw mapping for compat with tests (read/write by engine only)."""
        return self._state

    # -- lifecycle ------------------------------------------------------
    def ensure_today_instances(self, patient: dict) -> None:
        """Create DoseInstance entries for today's date if missing."""
        today = self.clock.today_str()
        pid = patient["patient_id"]
        group_id = patient["group_id"]
        nurse_user_id = patient["nurse_user_id"]
        label = patient["patient_label"]

        for d in patient["doses"]:
            t_str: str = d["time"]
            pill_text: str = d["text"]
            key = DoseKey(pid, today, t_str)
            if key in self._state:
                continue
            dt_local = self._combine(today, t_str)
            self._state[key] = DoseInstance(
                dose_key=key,
                patient_id=pid,
                patient_label=label,
                group_id=group_id,
                nurse_user_id=nurse_user_id,
                pill_text=pill_text,
                scheduled_dt_local=dt_local,
            )

    # -- status helpers -------------------------------------------------
    def set_status(self, inst: DoseInstance, status: Status) -> None:
        inst.status = status.value

    def status(self, inst: DoseInstance) -> Status:
        return Status(inst.status)

    # -- selection logic ------------------------------------------------
    def select_target_for_confirmation(
        self, now_local: datetime, patient: dict
    ) -> Optional[DoseInstance]:
        """
        Prefer actively waiting; else the nearest upcoming (same day),
        excluding already confirmed/escalated.
        """
        pid = patient["patient_id"]
        today = self.clock.today_str()

        # 1) Actively waiting
        for d in patient["doses"]:
            key = DoseKey(pid, today, d["time"])
            inst = self._state.get(key)
            if inst and self.status(inst) == Status.AWAITING:
                return inst

        # 2) Nearest upcoming today (not confirmed/escalated)
        best: Tuple[Optional[DoseInstance], Optional[datetime]] = (None, None)
        for d in patient["doses"]:
            key = DoseKey(pid, today, d["time"])
            inst = self._state.get(key)
            if not inst or self.status(inst) in (Status.CONFIRMED, Status.ESCALATED):
                continue
            dt = inst.scheduled_dt_local
            if dt >= now_local and (best[1] is None or dt < best[1]):
                best = (inst, dt)

        return best[0]

    # -- utilities ------------------------------------------------------
    def _combine(self, yyyy_mm_dd: str, hh_mm: str) -> datetime:
        y, m, d = (int(x) for x in yyyy_mm_dd.split("-"))
        hh, mm = (int(x) for x in hh_mm.split(":"))
        return datetime(y, m, d, hh, mm, tzinfo=self.tz)


### FILE: ./__init__.py


### FILE: ./tests/conftest.py
# pillsbot/tests/conftest.py
import sys
from pathlib import Path

# Add project root (the parent of 'pillsbot') to sys.path
ROOT = Path(__file__).resolve().parent.parent.parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))


### FILE: ./tests/integration/test_measure_unknown_behaviour.py
# pillsbot/tests/integration/test_measure_unknown_behavior.py
import pytest
from datetime import UTC, datetime
from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg


class FakeAdapter:
    def __init__(self):
        self.sent = []  # (kind, id, text)

    async def send_group_message(self, group_id, text):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))


class NoOpScheduler:
    def add_job(self, *args, **kwargs):
        pass


def make_engine():
    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        MEASURES = cfg.MEASURES
        RETRY_INTERVAL_S = 0.05
        MAX_RETRY_ATTEMPTS = 2
        TAKING_GRACE_INTERVAL_S = 60
        PATIENTS = [
            {
                "patient_id": 10,
                "patient_label": "P",
                "group_id": -10,
                "nurse_user_id": 20,
                "doses": [],  # none to avoid confirm effects
            }
        ]

    return ReminderEngine(Cfg, FakeAdapter())


@pytest.mark.asyncio
async def test_unknown_when_not_measure_nor_confirmation():
    eng = make_engine()
    await eng.start(NoOpScheduler())

    msg = IncomingMessage(
        group_id=-10,
        sender_user_id=10,
        text="hello there",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)

    assert any("невідомий показник" in t for _, _, t in eng.adapter.sent)


@pytest.mark.asyncio
async def test_no_unknown_for_confirmation():
    eng = make_engine()
    await eng.start(NoOpScheduler())

    msg = IncomingMessage(
        group_id=-10, sender_user_id=10, text="ok", sent_at_utc=datetime.now(UTC)
    )
    await eng.on_patient_message(msg)

    # For confirmation with no target doses, engine replies "too_early" instead of measure_unknown
    assert any("ще не на часі" in t for _, _, t in eng.adapter.sent)
    assert all("невідомий показник" not in t for _, _, t in eng.adapter.sent)


### FILE: ./tests/integration/test_retry_and_escalation.py
import asyncio
import pytest
from datetime import datetime, timedelta
from zoneinfo import ZoneInfo

from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg

class FakeAdapter:
    def __init__(self):
        self.sent = []

    async def send_group_message(self, group_id, text):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))

class NoOpScheduler:
    def __init__(self): pass
    def add_job(self, *args, **kwargs): pass

def make_engine(interval=0.05, max_attempts=2):
    now = datetime.now(cfg.TZ)
    dose_time = (now + timedelta(seconds=0.1)).strftime("%H:%M")
    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        RETRY_INTERVAL_S = interval
        MAX_RETRY_ATTEMPTS = max_attempts
        TAKING_GRACE_INTERVAL_S = 0
        PATIENTS = [{
            "patient_id": 10,
            "patient_label": "P",
            "group_id": -10,
            "nurse_user_id": 20,
            "doses": [{"time": dose_time, "text": "X"}],
        }]
    eng = ReminderEngine(Cfg, FakeAdapter())
    return eng

@pytest.mark.asyncio
async def test_retry_and_escalation():
    eng = make_engine(interval=0.05, max_attempts=2)
    await eng.start(NoOpScheduler())
    # Manually trigger the job (simulate scheduler firing)
    await eng._start_dose_job(patient_id=10, time_str=list(eng.state.keys())[0].time_str)
    # Wait enough for retries + escalation
    await asyncio.sleep(0.2)
    # Check an escalation happened
    assert any(kind=="dm" for (kind, _, _) in eng.adapter.sent)


### FILE: ./tests/test_adapter_flow.py
# pillsbot/tests/test_adapter_flow.py
import pytest
from unittest.mock import AsyncMock, Mock
from pillsbot.adapters.telegram_adapter import TelegramAdapter


@pytest.mark.asyncio
async def test_on_group_text_forwards_to_engine(monkeypatch):
    # Patch aiogram.Bot to avoid network/token validation
    class DummyBot:
        def __init__(self, *a, **k):
            pass

    # Fake Dispatcher with non-async register methods to avoid warnings
    class DummyDispatcher:
        def __init__(self):
            self.message = Mock()
            self.callback_query = Mock()

        def start_polling(self, bot):
            pass

    monkeypatch.setattr("pillsbot.adapters.telegram_adapter.Bot", DummyBot)
    monkeypatch.setattr(
        "pillsbot.adapters.telegram_adapter.Dispatcher", DummyDispatcher
    )

    mock_engine = AsyncMock()
    adapter = TelegramAdapter(
        "123456:ABCDEF-test", engine=mock_engine, patient_groups=[-100]
    )

    msg = type("M", (), {})()
    msg.chat = type("C", (), {"id": -100})()
    msg.text = "hi"
    msg.from_user = type("U", (), {"id": 1})()

    await adapter.on_group_text(msg)
    assert mock_engine.on_patient_message.await_count == 1


### FILE: ./tests/test_inline_confirm.py
# pillsbot/tests/test_inline_confirm.py
import pytest
from pillsbot.core.reminder_engine import ReminderEngine, DoseKey, Status
import pillsbot.config as cfg
from pillsbot.core.i18n import fmt  # import the i18n formatter


@pytest.mark.asyncio
async def test_inline_confirm_falls_back_to_selection():
    eng = ReminderEngine(cfg, adapter=None)
    await eng.start(None)

    patient = list(eng.patient_index.values())[0]
    key = DoseKey(patient["patient_id"], eng._today_str(), patient["doses"][0]["time"])
    inst = eng.state_mgr.get(key)
    eng.state_mgr.set_status(inst, Status.AWAITING)

    result = await eng.on_inline_confirm(
        group_id=patient["group_id"],
        from_user_id=patient["patient_id"],
        data="confirm:999:2020-01-01:00:00",  # invalid key to force fallback
        message_id=None,
    )

    assert fmt("cb_late_ok") in result["cb_text"]
    assert eng.state_mgr.status(inst) == Status.CONFIRMED


### FILE: ./tests/test_preconfirm.py
# tests/test_preconfirm.py
import pytest
from datetime import timedelta
from pillsbot.core.reminder_engine import ReminderEngine, DoseKey, Status
import pillsbot.config as cfg


@pytest.mark.asyncio
async def test_preconfirm_within_grace():
    eng = ReminderEngine(cfg, adapter=None)
    await eng.start(None)

    patient = list(eng.patient_index.values())[0]
    key = DoseKey(patient["patient_id"], eng._today_str(), patient["doses"][0]["time"])
    inst = eng.state_mgr.get(key)
    inst.scheduled_dt_local = eng.clock.now() + timedelta(
        seconds=eng.cfg.TAKING_GRACE_INTERVAL_S - 1
    )

    await eng._handle_confirmation_text(patient)

    assert eng.state_mgr.status(inst) == Status.CONFIRMED
    assert inst.preconfirmed


### FILE: ./tests/test_scheduler_wiring.py


### FILE: ./tests/unit/test_matcher.py
# pillsbot/tests/unit/test_matcher.py
from pillsbot.core.matcher import Matcher
from pillsbot import config as cfg


def test_matcher_positive_cases():
    # Use the same patterns as production config to keep tests realistic
    m = Matcher(cfg.CONFIRM_PATTERNS)
    for txt in ["Ок", "все ок!", "+", "да", "вже"]:
        assert m.matches_confirmation(txt)


def test_matcher_negative_cases():
    # Narrow pattern to ensure boundaries work as intended
    m = Matcher([r"\bтак\b"])
    assert not m.matches_confirmation("також")  # word boundary prevents false positive
    assert not m.matches_confirmation("random text")


### FILE: ./tests/unit/test_measurements_flow.py
# pillsbot/tests/unit/test_measurements_flow.py
import os
from datetime import UTC, datetime

from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg


class FakeAdapter:
    def __init__(self):
        self.sent = []  # (kind, id, text)

    async def send_group_message(self, group_id, text):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))


class NoOpScheduler:
    def add_job(self, *args, **kwargs):
        pass


def _cleanup_csvs(tmp_suffix: str):
    paths = [
        f"pillsbot/logs/pressure_{tmp_suffix}.csv",
        f"pillsbot/logs/weight_{tmp_suffix}.csv",
    ]
    for p in paths:
        try:
            os.remove(p)
        except FileNotFoundError:
            pass


def make_engine(tmp_suffix="x"):
    # Ensure a clean slate for this test run
    _cleanup_csvs(tmp_suffix)

    # Use test-specific CSV paths to avoid touching prod logs
    MEASURES = {k: dict(v) for k, v in cfg.MEASURES.items()}
    MEASURES["pressure"] = dict(
        MEASURES["pressure"], csv_file=f"pillsbot/logs/pressure_{tmp_suffix}.csv"
    )
    MEASURES["weight"] = dict(
        MEASURES["weight"], csv_file=f"pillsbot/logs/weight_{tmp_suffix}.csv"
    )

    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        MEASURES = {}  # set right after the class definition
        RETRY_INTERVAL_S = 0.05
        MAX_RETRY_ATTEMPTS = 2
        TAKING_GRACE_INTERVAL_S = 60
        PATIENTS = [
            {
                "patient_id": 100,
                "patient_label": "P",
                "group_id": -100,
                "nurse_user_id": 200,
                "doses": [],
                "measurement_checks": [{"measure_id": "pressure", "time": "23:59"}],
            }
        ]

    # IMPORTANT: assign here to avoid NameError inside class scope
    Cfg.MEASURES = MEASURES

    eng = ReminderEngine(Cfg, FakeAdapter())
    return eng


import pytest


@pytest.mark.asyncio
async def test_measurement_ack_and_csv():
    eng = make_engine(tmp_suffix="flow1")
    await eng.start(NoOpScheduler())
    # Send a good pressure message
    msg = IncomingMessage(
        group_id=-100,
        sender_user_id=100,
        text="BP 120/80/60",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)
    # Should have ack
    assert any("отримано показник" in t for _, _, t in eng.adapter.sent)


@pytest.mark.asyncio
async def test_daily_missing_then_ok():
    eng = make_engine(tmp_suffix="flow2")
    await eng.start(NoOpScheduler())

    # First check: no entry today -> missing reminder
    await eng._measurement_check_job(100, "pressure")
    assert any("сьогодні не отримано показник" in t for _, _, t in eng.adapter.sent)
    eng.adapter.sent.clear()

    # Now record a measurement (this will produce an ACK message)
    msg = IncomingMessage(
        group_id=-100,
        sender_user_id=100,
        text="pressure 120 80 60",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)
    assert any("отримано показник" in t for _, _, t in eng.adapter.sent)

    # Check again: should NOT send a "missing" reminder and should NOT append any new messages
    before = len(eng.adapter.sent)
    await eng._measurement_check_job(100, "pressure")
    after = len(eng.adapter.sent)
    assert before == after  # no additional messages
    # and specifically no "missing" text present
    assert not any("сьогодні не отримано показник" in t for _, _, t in eng.adapter.sent)


### FILE: ./tests/unit/test_measurements_parsing.py
# pillsbot/tests/unit/test_measurements_parsing.py
from pillsbot.core.measurements import MeasurementRegistry
from pillsbot import config as cfg


def make_registry():
    return MeasurementRegistry(cfg.TZ, cfg.MEASURES)


def test_pressure_positive_cases():
    reg = make_registry()
    mid, body = reg.match("тиск 120 80 60")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("BP 118/79/62")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("давление 125,85,59")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]

    # NEW: punctuation after keyword
    mid, body = reg.match("BP: 120/80/60")
    assert mid == "pressure"
    assert reg.parse(mid, body)["ok"]


def test_pressure_negative_cases():
    reg = make_registry()
    mid, body = reg.match("pressure 120/80")  # missing one
    assert mid == "pressure"
    assert not reg.parse(mid, body)["ok"]

    mid, body = reg.match("давление 120.5/80/60")  # decimal not allowed
    assert mid == "pressure"
    assert not reg.parse(mid, body)["ok"]


def test_weight_positive_cases():
    reg = make_registry()
    mid, body = reg.match("вага 102,4")
    assert mid == "weight"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("weight 73.0")
    assert mid == "weight"
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("вес 80")
    assert mid == "weight"
    assert reg.parse(mid, body)["ok"]

    # NEW: boundaries
    mid, body = reg.match("weight 0")
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("weight 0.0")
    assert reg.parse(mid, body)["ok"]

    mid, body = reg.match("weight 350.1234")
    assert reg.parse(mid, body)["ok"]


def test_weight_negative_cases():
    reg = make_registry()
    mid, body = reg.match("weight -5")
    r = reg.parse(mid, body)
    assert not r["ok"]

    mid, body = reg.match("взвешивание 80 кг")
    r = reg.parse(mid, body)
    assert not r["ok"]


def test_start_anchored():
    reg = make_registry()
    assert reg.match("моє давление 120 80 60") is None


### FILE: ./tests/unit/test_preconfirm_logic.py
from datetime import datetime, timedelta

from pillsbot.core.reminder_engine import ReminderEngine, IncomingMessage
from pillsbot import config as cfg


class FakeAdapter:
    def __init__(self):
        self.sent = []  # (chat_id, text)

    async def send_group_message(self, group_id, text):
        self.sent.append(("group", group_id, text))

    async def send_nurse_dm(self, user_id, text):
        self.sent.append(("dm", user_id, text))


def make_engine():
    class Cfg:
        TZ = cfg.TZ
        LOG_FILE = cfg.LOG_FILE
        CONFIRM_PATTERNS = cfg.CONFIRM_PATTERNS
        RETRY_INTERVAL_S = 1
        MAX_RETRY_ATTEMPTS = 2
        TAKING_GRACE_INTERVAL_S = 60
        PATIENTS = [
            {
                "patient_id": 1,
                "patient_label": "Test Patient",
                "group_id": -1,
                "nurse_user_id": 2,
                "doses": [
                    {
                        "time": (datetime.now(cfg.TZ) + timedelta(minutes=1)).strftime(
                            "%H:%M"
                        ),
                        "text": "Vit D",
                    }
                ],
            }
        ]

    adapter = FakeAdapter()
    eng = ReminderEngine(Cfg, adapter)
    return eng, adapter


import pytest  # noqa: E402
from datetime import UTC  # noqa: E402


@pytest.mark.asyncio
async def test_preconfirm_within_grace():
    eng, ad = make_engine()
    await eng.start(
        scheduler=type("S", (), {"add_job": lambda *a, **k: None})()
    )  # no-op scheduler
    # Send a confirmation now; next dose is within 60s
    msg = IncomingMessage(
        group_id=-1,
        sender_user_id=1,
        text="ок",
        sent_at_utc=datetime.now(UTC),
    )
    await eng.on_patient_message(msg)
    # Expect preconfirm ack
    assert any("заздалегідь" in t for _, _, t in ad.sent)


### FILE: ./tests/unit/test_retry_semantics.py


### FILE: ./tests/unit/test_validation_config.py
# pillsbot/tests/unit/test_validation_config.py
import pytest
from pillsbot.core.config_validation import validate_config
from zoneinfo import ZoneInfo


class CfgOk:
    TZ = ZoneInfo("Europe/Kyiv")
    MEASURES = {
        "pressure": {
            "label": "Тиск",
            "patterns": ["тиск", "давление", "BP", "pressure"],
            "csv_file": "pillsbot/logs/pressure_test.csv",
            "parser_kind": "int3",
            "separators": [" ", ",", "/"],
        }
    }
    PATIENTS = [
        {
            "patient_id": 1,
            "patient_label": "A",
            "group_id": -1,
            "nurse_user_id": 2,
            "doses": [{"time": "08:00", "text": "Med"}],
            "measurement_checks": [{"measure_id": "pressure", "time": "21:00"}],
        }
    ]


def test_validate_ok():
    validate_config(CfgOk)


def test_duplicate_measurement_check_times_raises():
    class CfgDup(CfgOk):
        PATIENTS = [
            {
                "patient_id": 1,
                "patient_label": "A",
                "group_id": -1,
                "nurse_user_id": 2,
                "doses": [{"time": "08:00", "text": "Med"}],
                "measurement_checks": [
                    {"measure_id": "pressure", "time": "21:00"},
                    {"measure_id": "pressure", "time": "21:00"},
                ],
            }
        ]

    with pytest.raises(ValueError):
        validate_config(CfgDup)


