### FILE: ./pillsbot/adapters/telegram_adapter.py
# pillsbot/adapters/telegram_adapter.py
from __future__ import annotations

import asyncio
import logging
from typing import Any, Iterable

from aiogram import Bot, Dispatcher, F
from aiogram.filters import CommandStart, Command
from aiogram.types import (
    Message,
    CallbackQuery,
    InlineKeyboardMarkup,
    InlineKeyboardButton,
    ReplyKeyboardRemove,
)

from pillsbot.core.reminder_engine import IncomingMessage
from pillsbot.core.logging_utils import kv
from pillsbot.core.i18n import MESSAGES
from pillsbot.debug_ids import print_group_and_users_best_effort


class TelegramAdapter:
    """
    Aiogram 3.x adapter implementing the v4 inline-only UX:

    • Single dynamic inline menu at the bottom (flat, no submenus, no pinned message).
    • Exactly one menu message exists in the chat: before posting a new one, delete the old one.
    • Accept both tap and text confirmation (engine handles text; adapter routes taps).
    • Patient-only actions; others are ignored silently (logged).
    """

    def __init__(
        self, bot_token: str, engine: Any, patient_groups: Iterable[int]
    ) -> None:
        self.bot = Bot(token=bot_token, parse_mode=None)
        self.dp = Dispatcher()

        self.engine = engine
        self.patient_groups = set(patient_groups)

        self.log = logging.getLogger("pillsbot.adapter")

        # Per-chat menu lifecycle (v4: delete-then-post)
        self._last_menu_msg_id: dict[int, int] = {}
        # NEW: per-chat lock to serialize delete→post across concurrent sends
        self._menu_locks: dict[int, asyncio.Lock] = {}

        # ---- Handlers (IMPORTANT: commands first, then generic text) ----
        self.dp.message.register(self.on_start, CommandStart())
        self.dp.message.register(self.on_ids, Command("ids"))
        self.dp.message.register(self.on_group_text, F.text)
        self.dp.callback_query.register(self.on_callback, F.data.startswith("ui:"))

    # ------------------------------------------------------------------------------
    # Flat inline keyboard (single component; can_confirm toggles first row)
    # ------------------------------------------------------------------------------
    def build_menu_keyboard(self, *, can_confirm: bool) -> InlineKeyboardMarkup:
        rows: list[list[InlineKeyboardButton]] = []

        if can_confirm:
            rows.append(
                [
                    InlineKeyboardButton(
                        text="✅ " + MESSAGES["btn_confirm_taken"],
                        callback_data="ui:TAKE",
                    )
                ]
            )

        rows.append(
            [
                InlineKeyboardButton(
                    text=MESSAGES["btn_pressure"], callback_data="ui:PRESSURE"
                ),
                InlineKeyboardButton(
                    text=MESSAGES["btn_weight"], callback_data="ui:WEIGHT"
                ),
            ]
        )
        rows.append(
            [InlineKeyboardButton(text=MESSAGES["btn_help"], callback_data="ui:HELP")]        )

        return InlineKeyboardMarkup(inline_keyboard=rows)

    # ------------------------------------------------------------------------------
    # Menu posting (delete previous first) — now serialized per chat
    # ------------------------------------------------------------------------------
    async def post_menu(self, chat_id: int, text: str, *, can_confirm: bool) -> int:
        # Serialize all menu mutations for this chat to avoid races
        lock = self._menu_locks.setdefault(chat_id, asyncio.Lock())
        async with lock:
            # 1) Try to delete the previous menu message.
            old = self._last_menu_msg_id.get(chat_id)
            if old:
                try:
                    await self.bot.delete_message(chat_id, old)
                except Exception as e:
                    # Log and proceed to send a fresh menu anyway.
                    self.log.debug("menu.delete.fail " + kv(chat_id=chat_id, err=str(e)))

            # 2) Send the new menu message (text + inline keyboard).
            kb = self.build_menu_keyboard(can_confirm=can_confirm)
            msg = await self.bot.send_message(chat_id=chat_id, text=text, reply_markup=kb)

            # 3) Track it as the last menu.
            self._last_menu_msg_id[chat_id] = msg.message_id
            return msg.message_id

    # ------------------------------------------------------------------------------
    # Reply keyboard removal — done on /start (separate message)
    # ------------------------------------------------------------------------------
    async def clear_reply_keyboard_once(self, chat_id: int) -> None:
        try:
            await self.bot.send_message(
                chat_id,
                "Оновлення інтерфейсу…",
                reply_markup=ReplyKeyboardRemove(remove_keyboard=True),
            )
        except Exception:
            # Best-effort, ignore any errors (no rights, etc.)
            pass

    # ------------------------------------------------------------------------------
    # Handlers
    # ------------------------------------------------------------------------------
    async def on_start(self, message: Message) -> None:
        """
        v4 migration: on /start send a separate message with ReplyKeyboardRemove(),
        then post the state-appropriate menu (engine decides can_confirm).
        """
        chat_id = message.chat.id
        await self.clear_reply_keyboard_once(chat_id)
        await self.engine.show_current_menu(chat_id)

    async def on_group_text(self, message: Message) -> None:
        chat_id = message.chat.id
        text = message.text or ""
        sender_user_id = message.from_user.id if message.from_user else 0

        # Fallback guard: if a command slipped through, route it explicitly
        if text.startswith("/"):
            cmd = text.split()[0].split("@")[0].lower()
            if cmd == "/start":
                await self.on_start(message)
                return
            if cmd == "/ids":
                await self.on_ids(message)
                return

        self.log.info(
            "msg.in.group "
            + kv(group_id=chat_id, sender_user_id=sender_user_id, text=text)
        )

        if chat_id not in self.patient_groups:
            self.log.debug("msg.in.ignored " + kv(reason="not a patient group"))
            return

        sent_at_utc = getattr(message, "date", None)
        if sent_at_utc is None:
            from datetime import datetime, timezone as _tz
            sent_at_utc = datetime.now(_tz.utc)

        incoming = IncomingMessage(
            group_id=chat_id,
            sender_user_id=sender_user_id,
            text=text,
            sent_at_utc=sent_at_utc,
        )

        await self.engine.on_patient_message(incoming)

    async def on_callback(self, callback: CallbackQuery) -> None:
        """
        Flat UI actions:
        - ui:TAKE      → confirm (if awaiting)
        - ui:PRESSURE  → show hint + menu in ONE message; expect next input as pressure
        - ui:WEIGHT    → show hint + menu in ONE message; expect next input as weight
        - ui:HELP      → help text, then refresh menu

        Only the mapped patient may act. Others are ignored silently (logged).
        """
        chat_id = callback.message.chat.id if callback.message else 0
        from_user_id = callback.from_user.id if callback.from_user else 0
        data = callback.data or ""

        # Access control: patient-only
        expected_pid = None
        pid_mapping = getattr(self.engine, "group_to_patient", None)
        if isinstance(pid_mapping, dict):
            expected_pid = pid_mapping.get(chat_id)
        if expected_pid is not None and from_user_id != expected_pid:
            self.log.debug(
                "cb.ignored.nonpatient "
                + kv(group_id=chat_id, actor=from_user_id, expected=expected_pid)
            )
            # Ignore silently as per spec. Do not toast.
            return

        # Acknowledge the callback to clear the Telegram spinner
        try:
            await callback.answer()
        except Exception:
            pass

        # Route actions
        if data == "ui:TAKE":
            await self.engine.quick_confirm(chat_id, from_user_id)
            return

        if data == "ui:PRESSURE":
            await self.engine.show_hint_menu(chat_id, kind="pressure")
            return

        if data == "ui:WEIGHT":
            await self.engine.show_hint_menu(chat_id, kind="weight")
            return

        if data == "ui:HELP":
            await self.engine.show_help(chat_id)
            return

    async def on_ids(self, message: Message) -> None:
        """
        Debug command: /ids prints group id and best-effort participants to console only.
        No chat output, no menu refresh or deletions.
        """
        try:
            # Gather known participants for this group (patient + nurse).
            known_ids: set[int] = set()
            chat_id = message.chat.id

            pid_mapping = getattr(self.engine, "group_to_patient", {})
            pat_idx = getattr(self.engine, "patient_index", {})

            patient_id = pid_mapping.get(chat_id)
            if isinstance(patient_id, int):
                known_ids.add(patient_id)
                pdata = pat_idx.get(patient_id, {})
                nurse_id = pdata.get("nurse_user_id")
                if isinstance(nurse_id, int):
                    known_ids.add(nurse_id)

            await print_group_and_users_best_effort(
                self.bot, message, known_user_ids=list(known_ids)
            )
        except Exception as e:
            self.log.debug("ids.print.fail " + kv(err=str(e)))
        # Intentionally do nothing in chat (no reply).

    # ------------------------------------------------------------------------------
    # Outbound messaging (used by messenger)
    # ------------------------------------------------------------------------------
    async def send_group_message(
        self, group_id: int, text: str, reply_markup: Any | None = None
    ) -> int:
        self.log.info("msg.out.group " + kv(group_id=group_id, text=text))
        msg = await self.bot.send_message(
            chat_id=group_id, text=text, reply_markup=reply_markup
        )
        return msg.message_id

    async def send_nurse_dm(self, user_id: int, text: str) -> None:
        self.log.info("msg.out.dm " + kv(user_id=user_id, text=text))
        await self.bot.send_message(chat_id=user_id, text=text)

    # v4 menu hook used by ReminderMessenger
    async def send_menu_message(
        self, group_id: int, text: str, *, can_confirm: bool
    ) -> int:
        return await self.post_menu(group_id, text, can_confirm=can_confirm)

    async def run_polling(self) -> None:
        self.log.debug("polling.run")
        await self.bot.delete_webhook(drop_pending_updates=True)
        await self.dp.start_polling(self.bot)


__all__ = [
    "TelegramAdapter",
    "IncomingMessage",
]


### FILE: ./pillsbot/app.py
# pillsbot/app.py
from __future__ import annotations

import sys
from pathlib import Path
import asyncio
import logging
from typing import List, Tuple, Dict, Any
from datetime import datetime

# --------------------------------------------------------------------------------------
# Ensure project root is in sys.path so "import pillsbot.*" always works
# --------------------------------------------------------------------------------------
ROOT = Path(__file__).resolve().parent.parent
if str(ROOT) not in sys.path:
    sys.path.insert(0, str(ROOT))

import config as cfg  # noqa: E402
from config import get_bot_token, PATIENTS  # noqa: E402
from pillsbot.core.reminder_engine import ReminderEngine  # noqa: E402
from pillsbot.adapters.telegram_adapter import TelegramAdapter  # noqa: E402
from apscheduler.schedulers.asyncio import AsyncIOScheduler  # noqa: E402
from pillsbot.core.i18n import MESSAGES  # noqa: E402


def _now_hhmm(tz) -> str:
    """Return current local time in HH:MM for a given tzinfo."""
    return datetime.now(tz).strftime("%H:%M")


async def schedule_jobs(
    engine: ReminderEngine, timezone
) -> Tuple[AsyncIOScheduler, List[Tuple[int, str]]]:
    """
    Schedule daily dose reminders and (optionally) measurement checks from config.

    Returns (scheduler, immediate_doses) where immediate_doses is a list of (patient_id, '*')
    that must be triggered exactly once after startup.

    Note: The scheduler is created and configured here, but NOT started.
    """
    sched = AsyncIOScheduler(timezone=timezone)

    immediate: List[Tuple[int, str]] = []

    # Doses
    for p in PATIENTS:
        pid = p["patient_id"]
        for d in p["doses"]:
            t = d["time"]
            if t == "*":
                immediate.append((pid, t))
                continue
            hh, mm = (int(x) for x in t.split(":"))
            sched.add_job(
                engine._start_dose_job,  # async function
                trigger="cron",
                hour=hh,
                minute=mm,
                kwargs={"patient_id": pid, "time_str": t},
                id=f"dose:{pid}:{t}",
                replace_existing=True,
                coalesce=True,
                misfire_grace_time=300,
                max_instances=1,
            )

    # Measurement checks (only if engine supports it)
    if hasattr(engine, "_start_measurement_check_job"):
        for p in PATIENTS:
            pid = p["patient_id"]
            for chk in p.get("measurement_checks", []):
                t = chk["time"]
                hh, mm = (int(x) for x in t.split(":"))
                sched.add_job(
                    getattr(engine, "_start_measurement_check_job"),
                    trigger="cron",
                    hour=hh,
                    minute=mm,
                    kwargs={"patient_id": pid, "measure_id": chk["measure_id"]},
                    id=f"measure:{pid}:{chk['measure_id']}:{t}",
                    replace_existing=True,
                    coalesce=True,
                    misfire_grace_time=300,
                    max_instances=1,
                )

    return sched, immediate


def _patients_with_star_replaced(
    patients: List[Dict[str, Any]], hhmm: str
) -> List[Dict[str, Any]]:
    """
    Return a shallow-copied PATIENTS where any dose with time=='*' is replaced by HH:MM.
    This guarantees engine/state initialization pre-creates today's instances.
    """
    result: List[Dict[str, Any]] = []
    for p in patients:
        newp = dict(p)
        new_doses: List[Dict[str, Any]] = []
        for d in p.get("doses", []):
            if d.get("time") == "*":
                d = dict(d)
                d["time"] = hhmm
            new_doses.append(d)
        newp["doses"] = new_doses
        result.append(newp)
    return result


async def main() -> None:
    logging.basicConfig(level=logging.INFO)
    log = logging.getLogger("pillsbot.app")

    token = get_bot_token()

    # Break constructor cycle: adapter needs engine, engine needs adapter
    adapter = TelegramAdapter(
        bot_token=token,
        engine=None,  # placeholder; set real engine below
        patient_groups=[p["group_id"] for p in PATIENTS],
    )

    engine = ReminderEngine(config=cfg, adapter=adapter)

    # Attach engine back to adapter
    if hasattr(adapter, "attach_engine"):
        adapter.attach_engine(engine)
    else:
        adapter.engine = engine  # type: ignore[attr-defined]

    # Prepare scheduler and register jobs (do not start yet)
    sched, immediate = await schedule_jobs(engine, timezone=cfg.TZ)

    # Compute a single HH:MM substitute for all '*' doses at this startup
    now_hhmm = _now_hhmm(cfg.TZ)

    # Temporarily replace '*' with now_hhmm so engine/state pre-creates instances
    original_patients = cfg.PATIENTS
    try:
        cfg.PATIENTS = _patients_with_star_replaced(original_patients, now_hhmm)
        # Initialize engine (explicitly disable any legacy scheduler passthrough)
        await engine.start(scheduler=None)
    finally:
        cfg.PATIENTS = original_patients

    # --- IMPORTANT ORDER ---
    # 1) Startup greeting (one per group) BEFORE any reminders can publish
    for p in PATIENTS:
        await adapter.send_group_message(p["group_id"], MESSAGES["startup_greeting"])

    # 2) Trigger one-shot '*' doses immediately (use the same HH:MM as during init)
    for pid, _ in immediate:
        await engine._start_dose_job(patient_id=pid, time_str=now_hhmm)

    # 3) Only now start the scheduler
    sched.start()

    log.info("startup.ready patients=%d", len(PATIENTS))

    # Enter polling loop
    await adapter.run_polling()


if __name__ == "__main__":
    asyncio.run(main())


### FILE: ./pillsbot/config.py
"""
Runtime configuration for PillsBot (v4).
All times for scheduling/logging are Europe/Kyiv.
"""

from __future__ import annotations

import os
from typing import Any
from zoneinfo import ZoneInfo

# --------------------------------------------------------------------------------------
# Core bot settings
# --------------------------------------------------------------------------------------
# IMPORTANT: no hardcoded token in repo; provide via env or explicit override
BOT_TOKEN: str | None = None
TIMEZONE = "Europe/Kyiv"
TZ = ZoneInfo(TIMEZONE)

# Retry/escalation configuration
RETRY_INTERVAL_S = 60
MAX_RETRY_ATTEMPTS = 3
# TAKING_GRACE_INTERVAL_S = 600  # reserved for future; engine simplified in v4

# --------------------------------------------------------------------------------------
# Patterns (v4: text confirmation list — case-insensitive/trimmed)
# --------------------------------------------------------------------------------------
CONFIRM_PATTERNS = [
    r"^\s*ок\s*$",
    r"^\s*\+\s*$",
    r"^\s*так\s*$",
    r"^\s*окей\s*$",
    r"^\s*прийняв\s*$",
    r"^\s*прийняла\s*$",
]

# --------------------------------------------------------------------------------------
# Measurement definitions (v4)
# --------------------------------------------------------------------------------------
MEASURES: dict[str, dict[str, Any]] = {
    "pressure": {
        "label": "Тиск",
        "patterns": ["тиск", "давление", "bp", "pressure"],
        "csv_file": "pillsbot/logs/pressure.csv",
        "parser_kind": "int2",  # exactly two integers
        "separators": [" ", ",", "/"],  # allowed separators between the two numbers
    },
    "weight": {
        "label": "Вага",
        "patterns": ["вага", "вес", "взвешивание", "weight"],
        "csv_file": "pillsbot/logs/weight.csv",
        "parser_kind": "float1",  # exactly one number
        "decimal_commas": True,  # accept "72,5"
    },
}

# --------------------------------------------------------------------------------------
# Logging
# --------------------------------------------------------------------------------------
LOG_FILE = "pillsbot/logs/pills.csv"
AUDIT_LOG_FILE = "pillsbot/logs/audit.log"

# --------------------------------------------------------------------------------------
# Patient roster (example/demo values; replace with real IDs)
# --------------------------------------------------------------------------------------
PATIENTS: list[dict[str, Any]] = [
    {
        "patient_id": 382163513,
        "patient_label": "Іван Петров",
        "group_id": -1002690368389,
        "nurse_user_id": 7391874317,
        "doses": [
            {"time": "*", "text": "Вітамін Д"},
            {"time": "21:00", "text": "Парацетамол"},
        ],
        # Optional daily measurement checks (per measure)
        "measurement_checks": [
            {"measure_id": "pressure", "time": "14:16"},
            {"measure_id": "weight", "time": "21:00"},
        ],
    },
]


def get_bot_token() -> str:
    token = BOT_TOKEN or os.getenv("BOT_TOKEN")
    if not token:
        raise RuntimeError(
            "Bot token is not set. Set env var BOT_TOKEN or override BOT_TOKEN in config.py."
        )
    return token


### FILE: ./pillsbot/core/config_validation.py
# pillsbot/core/config_validation.py
from __future__ import annotations

from typing import Any, Dict, List
import re


_TIME_RE = re.compile(r"^\d{2}:\d{2}$")


def _is_valid_hhmm(s: str) -> bool:
    if not _TIME_RE.match(s):
        return False
    hh, mm = (int(x) for x in s.split(":", 1))
    return 0 <= hh <= 23 and 0 <= mm <= 59


def validate_config(cfg: Any) -> None:
    """Validate runtime configuration before starting the bot.

    v5 changes:
    - Dose time may be '*' (fire immediately after startup) OR HH:MM.
    - All other rules are preserved.
    """
    patients: List[Dict[str, Any]] = getattr(cfg, "PATIENTS", None)
    if not isinstance(patients, list) or not patients:
        raise ValueError("PATIENTS must be a non-empty list")

    seen_keys: set[tuple[int, str]] = set()
    for p in patients:
        for key in ("patient_id", "patient_label", "group_id", "nurse_user_id", "doses"):
            if key not in p:
                raise ValueError(f"patient missing required field: {key}")
        pid = p["patient_id"]
        doses = p["doses"]
        if not isinstance(doses, list) or not doses:
            raise ValueError(f"patient {pid}: 'doses' must be a non-empty list")

        for d in doses:
            if "time" not in d or "text" not in d:
                raise ValueError(f"patient {pid}: each dose must have 'time' and 'text'")
            t = d["time"]
            if t != "*" and not _is_valid_hhmm(t):
                raise ValueError(f"patient {pid}: invalid dose time '{t}' (expected HH:MM or '*')")
            if t != "*":
                # Uniqueness per patient (ignore '*' which is one-shot at startup)
                k = (pid, t)
                if k in seen_keys:
                    raise ValueError(f"patient {pid}: duplicate dose time '{t}'")
                seen_keys.add(k)
            if not str(d["text"]).strip():
                raise ValueError(f"patient {pid}: dose 'text' must be non-empty")

    # Confirmation patterns
    pats = getattr(cfg, "CONFIRM_PATTERNS", None)
    if not isinstance(pats, list) or not pats or not all(isinstance(x, str) and x for x in pats):
        raise ValueError("CONFIRM_PATTERNS must be a non-empty list of strings")

    # Measures (consistent with v4)
    measures = getattr(cfg, "MEASURES", None)
    if not isinstance(measures, dict) or not measures:
        raise ValueError("MEASURES must be a non-empty dict")
    for mid, m in measures.items():
        if not isinstance(m, dict):
            raise ValueError(f"Measure '{mid}' must be a dict")
        if not m.get("label"):
            raise ValueError(f"Measure '{mid}' is missing 'label'")
        patterns = m.get("patterns")
        if not isinstance(patterns, list) or not patterns:
            raise ValueError(f"Measure '{mid}' must define non-empty 'patterns'")
        if not m.get("csv_file"):
            raise ValueError(f"Measure '{mid}' must define 'csv_file'")


### FILE: ./pillsbot/core/i18n.py
from __future__ import annotations

"""
i18n catalog.

This file preserves v4 keys and adds v5 keys + any keys used by the v4 engine
(e.g., ack_confirm, prompt_pressure, prompt_weight).
"""

MESSAGES = {
    # Menu texts (technical/idle)
    "reminder_text": "Час прийняти ліки. Підтвердіть прийом або оберіть дію нижче.",
    "idle_text": "Що зробимо? Оберіть дію нижче.",
    # Buttons
    "btn_confirm_taken": "Ліки вже прийнято",
    "btn_pressure": "Тиск",
    "btn_weight": "Вага",
    "btn_help": "Help",
    # Prompts / Help
    "help_text": (
        "Ви можете підтвердити прийом ліків кнопкою нижче або текстом.\n"
        "Доступні вимірювання: тиск, вага."
    ),
    # Contentful group lines
    "reminder_line": "Час прийняти ліки: {pill_text}",
    # Nurse DMs (existing)
    "escalate_dm": "пацієнт ({patient_label}): пропустив {date} {time}, {pill_text}",
    "nurse_late_confirm_dm": (
        "пацієнт ({patient_label}) підтвердив прийом ПІСЛЯ ескалації: "
        "{date} {time}, {pill_text}"
    ),
    # Engine-required (restored)
    "ack_confirm": "Готово! Прийом зафіксовано.",
    "ack_pressure": "Записав тиск {systolic}/{diastolic}.",
    "ack_pressure_pulse": "Записав тиск {systolic}/{diastolic}, пульс {pulse}.",
    "unknown_text": "Не вдалося розпізнати це повідомлення.",
    "prompt_pressure": "Будь ласка, надішліть вимір тиску у форматі «120/80».",
    "prompt_weight": "Будь ласка, надішліть вагу у кілограмах (наприклад, 72.4).",
}

# v5 additions
MESSAGES.update(
    {
        "reminder_retry_prefix": "Нагадування {n}: ",
        "escalate_group": "Пропущено прийом ліків!!! Повідомлення відправлено медичній медичній сестрі".replace(
            " медичній медичній", " медичній"
        ),  # guard against accidental dup
        "startup_greeting": "Всім доброго дня!",
    }
)


def fmt(key: str, **kwargs) -> str:
    return MESSAGES[key].format(**kwargs)


### FILE: ./pillsbot/core/logging_utils.py
# pillsbot/core/logging_utils.py
from __future__ import annotations

import logging
import os
from logging.handlers import RotatingFileHandler
from typing import Any

LOG_FORMAT = "%(asctime)s %(levelname)s %(name)s — %(message)s"
DATE_FORMAT = "%Y-%m-%d %H:%M:%S"


def setup_logging(cfg: Any) -> logging.Logger:
    """
    Configure logging:
    - Console shows INFO and above (clean runtime output).
    - Audit log file stores DEBUG and above (full trace).
    """
    log_dir = os.path.dirname(cfg.AUDIT_LOG_FILE)
    if log_dir:
        os.makedirs(log_dir, exist_ok=True)

    root = logging.getLogger("pillsbot")
    root.setLevel(logging.DEBUG)  # Allow DEBUG to propagate to file handler

    fmt = logging.Formatter(LOG_FORMAT, DATE_FORMAT)

    # File handler — DEBUG level, full history
    fh = RotatingFileHandler(
        cfg.AUDIT_LOG_FILE, maxBytes=1_000_000, backupCount=10, encoding="utf-8"
    )
    fh.setFormatter(fmt)
    fh.setLevel(logging.DEBUG)

    # Console handler — INFO level, clean output
    ch = logging.StreamHandler()
    ch.setFormatter(fmt)
    ch.setLevel(logging.INFO)

    root.handlers.clear()
    root.addHandler(fh)
    root.addHandler(ch)

    return root


def kv(**kwargs: Any) -> str:
    """Key=value compact formatting (values repr()'d for clarity)."""
    return " ".join(f"{k}={v!r}" for k, v in kwargs.items())


### FILE: ./pillsbot/core/matcher.py
# pillsbot/core/matcher.py
from __future__ import annotations

import re
from typing import Iterable, List, Pattern


class Matcher:
    """
    Regex-based confirmation matcher (Unicode + case-insensitive).
    All matching semantics live in the provided patterns (see config.CONFIRM_PATTERNS).
    No input normalization or pattern rewriting happens here.
    """

    def __init__(self, patterns: Iterable[str]) -> None:
        flags = re.IGNORECASE | re.UNICODE
        self._compiled: List[Pattern[str]] = [re.compile(p, flags) for p in patterns]

    def matches_confirmation(self, text: str | None) -> bool:
        if not text:
            return False
        return any(rx.search(text) for rx in self._compiled)


__all__ = ["Matcher"]


### FILE: ./pillsbot/core/measurements.py
# pillsbot/core/measurements.py
from __future__ import annotations

import os
import re
from dataclasses import dataclass
from datetime import datetime, date
from typing import Any, Dict, List, Optional, Tuple


@dataclass
class MeasureDef:
    id: str
    label: str
    patterns: List[str]
    csv_file: str
    parser_kind: str  # legacy hints: "int2" | "float1"
    separators: Optional[List[str]] = None  # legacy for pressure
    decimal_commas: Optional[bool] = None  # legacy for weight


class MeasurementRegistry:
    """
    Central registry for measurement parsing + storage (v4).

    * Start-anchored dispatch by configured patterns (typed keywords like "тиск", "вага").
    * Free-form tolerant parsers are provided below and should be used by the engine.
    * CSV append with header creation.
    * 'has_today' helper for daily checks.
    """

    def __init__(self, tz, measures_cfg: Dict[str, Dict[str, Any]] | None = None):
        self.tz = tz
        self.measures: Dict[str, MeasureDef] = {}
        self._compiled: Dict[str, re.Pattern[str]] = {}
        measures_cfg = measures_cfg or {}
        flags = re.IGNORECASE | re.UNICODE

        for mid, m in measures_cfg.items():
            md = MeasureDef(
                id=mid,
                label=m["label"],
                patterns=m["patterns"],
                csv_file=m["csv_file"],
                parser_kind=m.get("parser_kind", ""),
                separators=m.get("separators"),
                decimal_commas=m.get("decimal_commas"),
            )
            self.measures[mid] = md
            # ^\s*(kw1|kw2|...)\b[:\-]?\s*(?P<body>.*)?$
            union = "|".join(re.escape(p) for p in md.patterns)
            self._compiled[mid] = re.compile(
                rf"^\s*(?:{union})\b[:\-]?\s*(?P<body>.+)?$", flags
            )

    def available(self) -> List[str]:
        return list(self.measures.keys())

    def get_label(self, measure_id: str) -> str:
        return self.measures[measure_id].label

    # ---- Dispatch by typed keyword (start-anchored) ----
    def match(self, text: str | None) -> Optional[Tuple[str, str]]:
        t = text or ""
        for mid, rx in self._compiled.items():
            m = rx.match(t)
            if m:
                body = (m.group("body") or "").strip()
                return mid, body
        return None

    # ---- CSV writing ----
    def append_csv(
        self,
        measure_id: str,
        dt_local: datetime,
        patient_id: int,
        patient_label: str,
        values: tuple,
    ) -> None:
        """
        Appends one row to the measure CSV.

        For 'pressure' we always use the schema:
          date_time_local,patient_id,patient_label,systolic,diastolic,pulse
        If pulse is absent, the 'pulse' column is left blank.
        """
        md = self.measures[measure_id]
        path = md.csv_file
        os.makedirs(os.path.dirname(path), exist_ok=True)
        is_new = not os.path.exists(path)

        with open(path, "a", encoding="utf-8") as f:
            if is_new:
                if measure_id == "pressure":
                    f.write(
                        "date_time_local,patient_id,patient_label,systolic,diastolic,pulse\n"
                    )
                elif measure_id == "weight":
                    f.write("date_time_local,patient_id,patient_label,weight\n")
                else:
                    cols = ",".join(f"value{i + 1}" for i in range(len(values)))
                    f.write(f"date_time_local,patient_id,patient_label,{cols}\n")

            ts = dt_local.strftime("%Y-%m-%d %H:%M")
            if measure_id == "pressure":
                if len(values) == 3:
                    sys_v, dia_v, pulse_v = values
                    f.write(f"{ts},{patient_id},{patient_label},{sys_v},{dia_v},{pulse_v}\n")
                elif len(values) == 2:
                    sys_v, dia_v = values
                    f.write(f"{ts},{patient_id},{patient_label},{sys_v},{dia_v},\n")
                else:
                    f.write(f"{ts},{patient_id},{patient_label},,,\n")
            elif measure_id == "weight":
                (w,) = values
                f.write(f"{ts},{patient_id},{patient_label},{w}\n")
            else:
                vals = ",".join(str(x) for x in values)
                f.write(f"{ts},{patient_id},{patient_label},{vals}\n")

    # ---- Daily check helper ----
    def has_today(self, measure_id: str, patient_id: int, date_local: date) -> bool:
        md = self.measures[measure_id]
        path = md.csv_file
        if not os.path.exists(path):
            return False
        with open(path, "r", encoding="utf-8") as f:
            _ = f.readline()  # header
            for line in f:
                line = line.strip()
                if not line:
                    continue
                parts = line.split(",")
                if len(parts) < 3:
                    continue
                dt_str = parts[0].strip()
                pid_str = parts[1].strip()
                try:
                    dt = datetime.strptime(dt_str, "%Y-%m-%d %H:%M")
                    pid = int(pid_str)
                except Exception:
                    continue
                if pid == patient_id and dt.date() == date_local:
                    return True
        return False


# ======================================================================================
# Free-form tolerant parsers used by the engine (Option A)
# ======================================================================================

_INT_RE = re.compile(r"(?<!\d)(\d{1,3})(?!\d)")
_FLOAT_RE = re.compile(r"(?<!\d)(\d{1,3}(?:[.,]\d{1,2})?)(?!\d)")


def parse_pressure_free(text: str) -> Dict[str, Any]:
    """
    Accepts:
      - 120/80
      - 120 80
      - 120-80
      - 120 на 80
      - optional 3rd number as pulse: "... 72"
    Returns:
      {"ok": True, "sys": int, "dia": int, "pulse": Optional[int]}
      or {"ok": False, "error": "one_number"|"range"|"unrecognized"}
    """
    t = (text or "").strip()
    # Normalize separators "на" and punctuation to space to make number extraction robust
    t = (
        t.replace("/", " ")
        .replace("-", " ")
        .replace("—", " ")
        .replace("–", " ")
        .replace(":", " ")
    )
    t = re.sub(r"\bна\b", " ", t, flags=re.IGNORECASE | re.UNICODE)

    nums = [int(m.group(1)) for m in _INT_RE.finditer(t)]
    if len(nums) == 1:
        return {"ok": False, "error": "one_number"}
    if len(nums) < 2:
        return {"ok": False, "error": "unrecognized"}

    sys_v = nums[0]
    dia_v = nums[1]
    pulse_v = nums[2] if len(nums) >= 3 else None

    # Range checks
    if not (70 <= sys_v <= 250) or not (40 <= dia_v <= 150):
        return {"ok": False, "error": "range"}
    if pulse_v is not None and not (30 <= pulse_v <= 220):
        return {"ok": False, "error": "range"}

    return {"ok": True, "sys": sys_v, "dia": dia_v, "pulse": pulse_v}


def parse_weight_free(text: str) -> Dict[str, Any]:
    """
    Accepts one numeric token (dot or comma decimal), units optional (кг/kg).
    Returns:
      {"ok": True, "kg": float} or
      {"ok": False, "error": "likely_pressure"|"range"|"unrecognized"}
    """
    t = (text or "").strip()
    # Strip units
    t = re.sub(r"\s*(кг|kg)\b", "", t, flags=re.IGNORECASE | re.UNICODE)
    nums = [m.group(1) for m in _FLOAT_RE.finditer(t)]

    if len(nums) == 0:
        return {"ok": False, "error": "unrecognized"}
    if len(nums) > 1:
        # Two or more numbers usually indicate pressure
        return {"ok": False, "error": "likely_pressure"}

    token = nums[0].replace(",", ".")
    try:
        v = float(token)
    except ValueError:
        return {"ok": False, "error": "unrecognized"}

    if not (25.0 <= v <= 300.0):
        return {"ok": False, "error": "range"}

    return {"ok": True, "kg": v}


### FILE: ./pillsbot/core/reminder_engine.py
# pillsbot/core/reminder_engine.py
from __future__ import annotations

import asyncio
import contextlib
import logging
from dataclasses import dataclass
from datetime import datetime
from typing import Any, Optional, Dict, Set
from zoneinfo import ZoneInfo

from pillsbot.core.matcher import Matcher
from pillsbot.core.i18n import fmt, MESSAGES
from pillsbot.core.logging_utils import kv
from pillsbot.core.measurements import MeasurementRegistry, parse_pressure_free, parse_weight_free
from pillsbot.core.reminder_state import (
    Clock,
    Status,
    DoseKey,
    DoseInstance,
    ReminderState,
)
from pillsbot.core.reminder_messaging import ReminderMessenger
from pillsbot.core.reminder_retry import RetryManager


# -------------------------------------------------------------------------------------------------
# Public inbound message type (kept here for backwards-compat imports in tests)
# -------------------------------------------------------------------------------------------------
@dataclass
class IncomingMessage:
    group_id: int
    sender_user_id: int
    text: str
    sent_at_utc: datetime


class ReminderEngine:
    """
    v4: Single dynamic inline menu (delete old → post new). The engine ensures that
    after every visible event the last message is the menu.

    Option A: tapping Тиск/Вага shows a short hint with the inline menu in ONE message.
    The very next patient message is interpreted according to that hint (lightweight,
    one-shot expectation per chat). No long-lived sessions.
    """

    def __init__(self, config: Any, adapter: Any | None, clock: Optional[Clock] = None):
        self.cfg = config
        self.adapter = adapter
        tz = getattr(config, "TZ", None) or ZoneInfo(
            getattr(config, "TIMEZONE", "Europe/Kyiv")
        )
        self.clock = clock or Clock(tz)

        # Core services
        self.matcher = Matcher(getattr(config, "CONFIRM_PATTERNS", []))
        self.measures = MeasurementRegistry(tz, getattr(config, "MEASURES", None))
        self.log = logging.getLogger("pillsbot.engine")

        # State & messaging
        self.state_mgr = ReminderState(tz, self.clock)
        self.messenger = ReminderMessenger(adapter=self.adapter, log=self.log)
        self._escalated: Set[DoseKey] = set()

        self.patient_index: Dict[int, dict] = {}
        self.group_to_patient: Dict[int, int] = {}

        self.retry_mgr: Optional[RetryManager] = None

        # One-shot expectation for next user message after a tap: {"pressure"|"weight"}
        self._expect_next: Dict[int, str] = {}  # keyed by group_id

    def attach_adapter(self, adapter: Any) -> None:
        self.adapter = adapter
        self.messenger.adapter = adapter
        self.log.debug("engine.adapter.attached " + kv(kind=type(adapter).__name__))

    async def start(self, scheduler: Any | None) -> None:
        # Build indices
        for p in getattr(self.cfg, "PATIENTS", []):
            pid = p["patient_id"]
            self.patient_index[pid] = p
            self.group_to_patient[p["group_id"]] = pid
            self.state_mgr.ensure_today_instances(p)

        # Wire retry
        self.retry_mgr = RetryManager(
            interval_seconds=int(getattr(self.cfg, "RETRY_INTERVAL_S", 30)),
            max_attempts=int(getattr(self.cfg, "MAX_RETRY_ATTEMPTS", 3)),
            send_repeat=self._send_repeat_wrapper,
            on_escalate=self._on_escalate_wrapper,
            set_status=self.state_mgr.set_status,
            get_status=self.state_mgr.status,
            logger=self.log,
        )

        # Optional scheduler passthrough kept for compatibility
        if scheduler is not None:
            try:
                for p in getattr(self.cfg, "PATIENTS", []):
                    for d in p["doses"]:
                        scheduler.add_job(
                            self._start_dose_job,
                            kwargs={
                                "patient_id": p["patient_id"],
                                "time_str": d["time"],
                            },
                        )
                    for chk in p.get("measurement_checks", []):
                        scheduler.add_job(
                            self._job_measure_check,
                            kwargs={
                                "patient_id": p["patient_id"],
                                "measure_id": chk["measure_id"],
                            },
                        )
            except Exception:
                pass

    # ---- incoming from adapter --------------------------------------------------------
    async def on_patient_message(self, msg: IncomingMessage) -> None:
        self.log.info(
            "msg.engine.in "
            + kv(
                group_id=msg.group_id,
                sender_user_id=msg.sender_user_id,
                text=(msg.text or ""),
            )
        )

        pid = self.group_to_patient.get(msg.group_id)
        if pid is None or pid != msg.sender_user_id:
            self.log.debug(
                "msg.engine.reject "
                + kv(
                    reason="patient-only",
                    group_id=msg.group_id,
                    sender_user_id=msg.sender_user_id,
                )
            )
            return

        patient = self.patient_index[pid]
        text = (msg.text or "").strip()
        group_id = patient["group_id"]

        # --- A) Confirmation via text (CRITICAL INTENT) ---
        if self.matcher.matches_confirmation(text.lower().strip()):
            await self._handle_confirmation_text(patient)
            return

        # --- B) Help commands (should not be blocked by hint expectation) ---
        if text.lower() in {"help", "?", "довідка"}:
            await self.show_help(group_id)
            return

        # --- C) One-shot expectation set by a recent tap (pressure/weight) ---
        expect = self._expect_next.pop(group_id, None)
        if expect == "pressure":
            await self._handle_pressure_text(patient, text)
            await self.show_current_menu(group_id)
            return
        if expect == "weight":
            await self._handle_weight_text(patient, text)
            await self.show_current_menu(group_id)
            return

        # --- D) Typed keywords (start-anchored), then tolerant parse on the body ---
        mm = self.measures.match(text)
        if mm:
            mid, body = mm
            if mid == "pressure":
                await self._handle_pressure_text(patient, body)
                await self.show_current_menu(group_id)
                return
            if mid == "weight":
                await self._handle_weight_text(patient, body)
                await self.show_current_menu(group_id)
                return

        # --- E) Fallback ---
        await self._reply(group_id, "unknown_text")
        await self.show_current_menu(group_id)

    # ---- menus / actions --------------------------------------------------------------
    async def show_current_menu(self, group_id: int) -> None:
        """
        Post exactly one menu at the bottom:
        - If a dose is actively AWAITING → show reminder text + menu with Confirm.
        - Otherwise → show idle text + menu without Confirm.
        """
        pid = self.group_to_patient.get(group_id)
        if pid is None:
            return
        patient = self.patient_index.get(pid)
        if not patient:
            return

        target = self.state_mgr.select_target_for_confirmation(
            self.clock.now(), patient
        )

        if target and self.state_mgr.status(target) == Status.AWAITING:
            await self.messenger.send_reminder_step(target)
            return

        await self.messenger.send_home_step(group_id, can_confirm=False)

    async def show_hint_menu(self, group_id: int, *, kind: str) -> None:
        """
        Show the short hint (pressure/weight) with the inline menu in ONE message,
        and set a one-shot expectation for the very next patient message.
        """
        pid = self.group_to_patient.get(group_id)
        if pid is None:
            return
        patient = self.patient_index.get(pid)
        if not patient:
            return

        # Set expectation
        if kind in {"pressure", "weight"}:
            self._expect_next[group_id] = kind

        # Can we show confirm row?
        target = self.state_mgr.select_target_for_confirmation(self.clock.now(), patient)
        can_confirm = bool(target and self.state_mgr.status(target) == Status.AWAITING)

        # Which hint text?
        text = MESSAGES["prompt_pressure"] if kind == "pressure" else MESSAGES["prompt_weight"]

        await self.messenger.send_menu(group_id, text=text, can_confirm=can_confirm)

    async def quick_confirm(self, group_id: int, from_user_id: int) -> None:
        """Handle '✅ TAKE' tap; patient-only is enforced upstream in adapter."""
        pid = self.group_to_patient.get(group_id)
        if pid is None or pid != from_user_id:
            return
        patient = self.patient_index.get(pid)
        if not patient:
            return
        await self._handle_confirmation_text(patient)

    async def show_help(self, group_id: int) -> None:
        await self._reply(group_id, "help_text")
        await self.show_current_menu(group_id)

    # ---- jobs / orchestration ----------------------------------------------------------
    async def _start_dose_job(self, *, patient_id: int, time_str: str) -> None:
        patient = self.patient_index.get(patient_id)
        if not patient:
            self.log.debug(
                "job.trigger.miss "
                + kv(reason="unknown patient", patient_id=patient_id)
            )
            return

        key = DoseKey(patient_id, self.clock.today_str(), time_str)
        inst = self.state_mgr.get(key)
        if inst is None:
            self.state_mgr.ensure_today_instances(patient)
            inst = self.state_mgr.get(key)
            if inst is None:
                self.log.error(
                    "job.trigger.miss "
                    + kv(
                        patient_id=patient_id, time=time_str, reason="state not created"
                    )
                )
                return

        if self.state_mgr.status(inst) == Status.CONFIRMED:
            self.log.debug(
                "job.trigger.skip "
                + kv(patient_id=patient_id, time=time_str, reason="confirmed")
            )
            return

        self.state_mgr.set_status(inst, Status.AWAITING)
        inst.attempts_sent = 1

        await self.messenger.send_reminder_step(inst)
        await self._start_retry(inst)

    async def _job_measure_check(self, *, patient_id: int, measure_id: str) -> None:
        patient = self.patient_index.get(patient_id)
        if not patient:
            return
        today = self.clock.now().date()
        if not self.measures.has_today(measure_id, patient_id, today):
            # Neutral line; menu refresh keeps UI consistent
            await self._reply(patient["group_id"], "unknown_text")
            await self.show_current_menu(patient["group_id"])

    # ---- retry glue -------------------------------------------------------------------
    async def _start_retry(self, inst: DoseInstance) -> None:
        if self.retry_mgr is None:
            return
        await self._stop_retry(inst)
        inst.retry_task = asyncio.create_task(self.retry_mgr.run(inst))

    async def _stop_retry(self, inst: DoseInstance) -> None:
        t = inst.retry_task
        if t and not t.done():
            t.cancel()
            with contextlib.suppress(asyncio.CancelledError):
                await t
        inst.retry_task = None

    async def _send_repeat_wrapper(self, inst: DoseInstance) -> None:
        # v4: final pre-send status check — if not AWAITING, do not send the retry.
        if self.state_mgr.status(inst) != Status.AWAITING:
            return
        await self.messenger.send_reminder_step(inst)

    async def _on_escalate_wrapper(self, inst: DoseInstance) -> None:
        # Send escalation messages
        await self.messenger.send_escalation(inst) if hasattr(self.messenger, "send_escalation") else None
        self._escalated.add(inst.dose_key)
        self._log_outcome_csv(inst, "escalated")
        # Keep the invariant "menu is last" after escalation.
        await self.show_current_menu(inst.group_id)

    # ---- confirmation handling ---------------------------------------------------------
    async def _handle_confirmation_text(self, patient: dict) -> None:
        now = self.clock.now()
        target = self.state_mgr.select_target_for_confirmation(now, patient)
        # Only allow confirmation when a dose is actively awaiting.
        if (not target) or (self.state_mgr.status(target) != Status.AWAITING):
            await self._reply(patient["group_id"], "unknown_text")
            await self.show_current_menu(patient["group_id"])
            return

        # Idempotent confirm
        if self.state_mgr.status(target) == Status.CONFIRMED:
            await self._reply(patient["group_id"], "ack_confirm")
            await self.show_current_menu(patient["group_id"])
            return

        self.state_mgr.set_status(target, Status.CONFIRMED)
        await self._stop_retry(target)
        self.log.info(
            "dose.confirm "
            + kv(
                patient_id=target.patient_id,
                time=target.dose_key.time_str,
                source="tap/text",
            )
        )

        if target.dose_key in self._escalated:
            await self.messenger.send_nurse_notice(
                target.nurse_user_id,
                fmt(
                    "nurse_late_confirm_dm",
                    patient_label=target.patient_label,
                    date=target.dose_key.date_str,
                    time=target.dose_key.time_str,
                    pill_text=target.pill_text,
                ),
            )
            self._escalated.discard(target.dose_key)

        self._log_outcome_csv(target, "confirmed")

        # Ack + refresh menu without confirm
        await self._reply(patient["group_id"], "ack_confirm")
        await self.show_current_menu(patient["group_id"])

    # ---- measurement handling ----------------------------------------------------------
    async def _handle_pressure_text(self, patient: dict, text: str) -> None:
        parsed = parse_pressure_free(text)
        gid = patient["group_id"]
        if parsed.get("ok"):
            now_local = self.clock.now()
            sys_v = parsed["sys"]
            dia_v = parsed["dia"]
            pulse_v = parsed.get("pulse")
            vals = (sys_v, dia_v) if pulse_v is None else (sys_v, dia_v, pulse_v)
            self.measures.append_csv(
                "pressure", now_local, patient["patient_id"], patient["patient_label"], vals
            )
            if pulse_v is None:
                await self._reply(gid, "ack_pressure", systolic=sys_v, diastolic=dia_v)
            else:
                await self._reply(
                    gid, "ack_pressure_pulse", systolic=sys_v, diastolic=dia_v, pulse=pulse_v
                )
        else:
            err = parsed.get("error")
            if err == "one_number":
                await self._reply(gid, "err_pressure_one")
            elif err == "range":
                await self._reply(gid, "err_pressure_range")
            else:
                await self._reply(gid, "err_pressure_unrec")

    async def _handle_weight_text(self, patient: dict, text: str) -> None:
        parsed = parse_weight_free(text)
        gid = patient["group_id"]
        if parsed.get("ok"):
            now_local = self.clock.now()
            kg = parsed["kg"]
            self.measures.append_csv(
                "weight", now_local, patient["patient_id"], patient["patient_label"], (kg,)
            )
            await self._reply(gid, "ack_weight", kg=kg)
        else:
            err = parsed.get("error")
            if err == "likely_pressure":
                await self._reply(gid, "err_weight_likely_pressure")
            elif err == "range":
                await self._reply(gid, "err_weight_range")
            else:
                await self._reply(gid, "err_weight_unrec")

    # ---- plain replies ---------------------------------------------------------------
    async def _reply(
        self, group_id: int, template_key: str, **fmt_args: Any
    ) -> Optional[int]:
        """Send a plain group message using i18n template (menu is managed by callers)."""
        return await self.messenger.send_group_template(
            group_id, template_key, **fmt_args
        )

    # ---- misc -------------------------------------------------------------------------
    def _log_outcome_csv(self, inst: DoseInstance, status: str) -> None:
        line = (
            f"{inst.scheduled_dt_local.strftime('%Y-%m-%d %H:%M')}, "
            f"{inst.patient_id}, {inst.patient_label}, {inst.pill_text}, {status}, {inst.attempts_sent}\n"
        )
        path = getattr(self.cfg, "LOG_FILE", "pillsbot/logs/pills.csv")
        import os

        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "a", encoding="utf-8") as f:
            f.write(line)

    @property
    def state(self):
        return self.state_mgr.mapping


### FILE: ./pillsbot/core/reminder_messaging.py
# pillsbot/core/reminder_messaging.py
from __future__ import annotations

from typing import Any
from datetime import datetime

from pillsbot.core.i18n import MESSAGES, fmt
from pillsbot.core.reminder_state import DoseInstance  # type: ignore


class ReminderMessenger:
    """
    Messaging layer that enforces:
    - Contentful lines are standalone, persistent group messages.
    - The last visible message is the SINGLE inline menu (adapter deletes the previous menu).
    - Backward-compatible API surface for the v4 engine (e.g., send_group_template).
    """

    def __init__(self, adapter: Any, log: Any) -> None:
        self.adapter = adapter
        self.log = log

    # ------------------- low-level -------------------
    async def send_group_line(self, group_id: int, text: str) -> int:
        """Send a raw, contentful line (persistent)."""
        return await self.adapter.send_group_message(group_id, text)

    async def send_group_template(self, group_id: int, key: str, **kwargs) -> int:
        """
        v4-compat: resolve an i18n template by key, then send as a persistent group line.
        This method intentionally does NOT post/refresh the menu; engine controls when to show the menu.
        """
        # Prefer explicit key lookup; if missing, fall back to formatting the key itself.
        try:
            text_tmpl = MESSAGES[key]
            text = text_tmpl.format(**kwargs)
        except KeyError:
            # Fallback: allow directly passing arbitrary templates through the same path.
            text = key.format(**kwargs) if kwargs else key
        return await self.send_group_line(group_id, text)

    async def send_menu(self, group_id: int, *, text: str, can_confirm: bool) -> int:
        """
        Post (or refresh) the menu. Adapter deletes the previous menu first.

        Adapter API compatibility:
        - Prefer v4-style 'post_menu(...)' if present.
        - Otherwise, fall back to 'send_menu_message(...)' if provided by the adapter.
        """
        if hasattr(self.adapter, "post_menu"):
            # v4 adapter API
            return await self.adapter.post_menu(
                group_id, text=text, can_confirm=can_confirm
            )
        elif hasattr(self.adapter, "send_menu_message"):
            # v5 adapter wrapper (if present)
            return await self.adapter.send_menu_message(
                group_id, text, can_confirm=can_confirm
            )
        raise AttributeError(
            "Adapter must provide 'post_menu' or 'send_menu_message' for menus"
        )

    async def send_nurse_notice(self, nurse_user_id: int, text: str) -> None:
        await self.adapter.send_nurse_dm(nurse_user_id, text)

    # ------------------- composed steps -------------------
    async def send_reminder_step(self, inst: DoseInstance) -> None:
        """
        Post a contentful reminder line (persisted) and then the actionable menu.
        Adds retry prefix for repeated attempts.
        """
        # Determine retry ordinal: first visible reminder is attempt 1 (no prefix).
        attempts = getattr(inst, "attempts_sent", 1) or 1
        retries = max(0, attempts - 1)
        base = fmt("reminder_line", pill_text=getattr(inst, "pill_text", ""))
        if retries > 0:
            line = fmt("reminder_retry_prefix", n=retries) + base
        else:
            line = base

        await self.send_group_line(inst.group_id, line)
        await self.send_menu(
            inst.group_id, text=MESSAGES["reminder_text"], can_confirm=True
        )

    async def send_home_step(self, group_id: int, *, can_confirm: bool) -> None:
        """Idle home message (technical/ephemeral text) inside the menu."""
        await self.send_menu(
            group_id, text=MESSAGES["idle_text"], can_confirm=can_confirm
        )

    async def send_escalation(self, inst: DoseInstance) -> None:
        """Send group escalation line (persisted) + DM to nurse, then refresh menu."""
        # Group message
        await self.send_group_line(inst.group_id, MESSAGES["escalate_group"])

        # DM to nurse
        dt: datetime = getattr(inst, "scheduled_dt_local", datetime.now())
        txt = fmt(
            "escalate_dm",
            patient_label=getattr(inst, "patient_label", ""),
            date=dt.strftime("%Y-%m-%d"),
            time=dt.strftime("%H:%M"),
            pill_text=getattr(inst, "pill_text", ""),
        )
        await self.send_nurse_notice(getattr(inst, "nurse_user_id", 0), txt)

        # Refresh menu as last message
        await self.send_home_step(inst.group_id, can_confirm=False)


### FILE: ./pillsbot/core/reminder_retry.py
# pillsbot/core/reminder_retry.py
from __future__ import annotations

import asyncio
from typing import Callable, Awaitable
from pillsbot.core.logging_utils import kv
from pillsbot.core.reminder_state import Status, DoseInstance


class RetryManager:
    """
    Runs the retry loop for a DoseInstance, escalating at the end.
    Keeps all timing policy here so engines stay small and testable.
    """

    def __init__(
        self,
        interval_seconds: int,
        max_attempts: int,
        *,
        send_repeat: Callable[[DoseInstance], Awaitable[None]],
        on_escalate: Callable[[DoseInstance], Awaitable[None]],
        set_status: Callable[[DoseInstance, Status], None],
        get_status: Callable[[DoseInstance], Status],
        logger,
    ) -> None:
        self.interval_seconds = interval_seconds
        self.max_attempts = max_attempts
        self.send_repeat = send_repeat
        self.on_escalate = on_escalate
        self.set_status = set_status
        self.get_status = get_status
        self.log = logger

    async def run(self, inst: DoseInstance) -> None:
        """
        Retry until confirmed or attempts exhausted. On exhaustion, escalate.
        Final pre-send status check happens in send_repeat wrapper.
        """
        try:
            while self.get_status(inst) not in (Status.CONFIRMED, Status.ESCALATED):
                await asyncio.sleep(self.interval_seconds)

                if self.get_status(inst) in (Status.CONFIRMED, Status.ESCALATED):
                    break

                inst.attempts_sent += 1
                if inst.attempts_sent > self.max_attempts:
                    self.set_status(inst, Status.ESCALATED)
                    self.log.info(
                        "retry.escalate "
                        + kv(
                            patient_id=inst.patient_id,
                            time=inst.dose_key.time_str,
                            attempts=inst.attempts_sent,
                        )
                    )
                    await self.on_escalate(inst)
                    break

                self.log.debug(
                    "retry.repeat "
                    + kv(
                        patient_id=inst.patient_id,
                        time=inst.dose_key.time_str,
                        attempt=inst.attempts_sent,
                    )
                )
                await self.send_repeat(inst)
        except asyncio.CancelledError:
            raise
        except Exception as e:  # defensive
            self.log.error(
                "retry.loop.error "
                + kv(
                    patient_id=inst.patient_id, time=inst.dose_key.time_str, err=str(e)
                )
            )


### FILE: ./pillsbot/core/reminder_state.py
# pillsbot/core/reminder_state.py
from __future__ import annotations

import asyncio
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
from typing import Dict, Optional, Tuple, Iterable
from zoneinfo import ZoneInfo


class Status(str, Enum):
    PENDING = "pending"
    AWAITING = "awaiting"
    CONFIRMED = "confirmed"
    ESCALATED = "escalated"


@dataclass(frozen=True)
class DoseKey:
    """Stable identity for a single scheduled dose."""

    patient_id: int
    date_str: str  # YYYY-MM-DD (engine-local date string)
    time_str: str  # HH:MM


@dataclass
class DoseInstance:
    """Mutable runtime state for a scheduled dose occurrence."""

    dose_key: DoseKey
    patient_id: int
    patient_label: str
    group_id: int
    nurse_user_id: int
    pill_text: str
    scheduled_dt_local: datetime
    status: str = Status.PENDING.value
    attempts_sent: int = 0
    preconfirmed: bool = False
    retry_task: Optional[asyncio.Task] = None
    last_message_ids: list[int] = field(default_factory=list)  # debug/trace only


class Clock:
    """Injectable, testable clock bound to a timezone."""

    def __init__(self, tz: ZoneInfo):
        self.tz = tz

    def now(self) -> datetime:
        return datetime.now(self.tz)

    def today_str(self) -> str:
        return self.now().strftime("%Y-%m-%d")


class ReminderState:
    """
    Owns the in-memory state and selection logic.
    Only manipulates DoseInstance objects; orchestration lives in the engine.
    """

    def __init__(self, tz: ZoneInfo, clock: Clock):
        self.tz = tz
        self.clock = clock
        self._state: Dict[DoseKey, DoseInstance] = {}

    # -- dict-like read access for compatibility with existing tests --
    def get(self, key: DoseKey) -> Optional[DoseInstance]:
        return self._state.get(key)

    def values(self) -> Iterable[DoseInstance]:
        return self._state.values()

    def keys(self) -> Iterable[DoseKey]:
        return self._state.keys()

    @property
    def mapping(self) -> Dict[DoseKey, DoseInstance]:
        """Expose the raw mapping for compat with tests (read/write by engine only)."""
        return self._state

    # -- lifecycle ------------------------------------------------------
    def ensure_today_instances(self, patient: dict) -> None:
        """Create DoseInstance entries for today's date if missing."""
        today = self.clock.today_str()
        pid = patient["patient_id"]
        group_id = patient["group_id"]
        nurse_user_id = patient["nurse_user_id"]
        label = patient["patient_label"]

        for d in patient["doses"]:
            t_str: str = d["time"]
            pill_text: str = d["text"]
            key = DoseKey(pid, today, t_str)
            if key in self._state:
                continue
            dt_local = self._combine(today, t_str)
            self._state[key] = DoseInstance(
                dose_key=key,
                patient_id=pid,
                patient_label=label,
                group_id=group_id,
                nurse_user_id=nurse_user_id,
                pill_text=pill_text,
                scheduled_dt_local=dt_local,
            )

    # -- status helpers -------------------------------------------------
    def set_status(self, inst: DoseInstance, status: Status) -> None:
        inst.status = status.value

    def status(self, inst: DoseInstance) -> Status:
        return Status(inst.status)

    # -- selection logic ------------------------------------------------
    def select_target_for_confirmation(
        self, now_local: datetime, patient: dict
    ) -> Optional[DoseInstance]:
        """
        Prefer actively waiting; else the nearest upcoming (same day),
        excluding already confirmed/escalated.
        """
        pid = patient["patient_id"]
        today = self.clock.today_str()

        # 1) Actively waiting
        for d in patient["doses"]:
            key = DoseKey(pid, today, d["time"])
            inst = self._state.get(key)
            if inst and self.status(inst) == Status.AWAITING:
                return inst

        # 2) Nearest upcoming today (not confirmed/escalated)
        best: Tuple[Optional[DoseInstance], Optional[datetime]] = (None, None)
        for d in patient["doses"]:
            key = DoseKey(pid, today, d["time"])
            inst = self._state.get(key)
            if not inst or self.status(inst) in (Status.CONFIRMED, Status.ESCALATED):
                continue
            dt = inst.scheduled_dt_local
            if dt >= now_local and (best[1] is None or dt < best[1]):
                best = (inst, dt)

        return best[0]

    # -- utilities ------------------------------------------------------
    def _combine(self, yyyy_mm_dd: str, hh_mm: str) -> datetime:
        y, m, d = (int(x) for x in yyyy_mm_dd.split("-"))
        # Handle special case where time is "*" (any time)
        if hh_mm == "*":
            hh, mm = 12, 0  # Default to noon for "any time" doses
        else:
            hh, mm = (int(x) for x in hh_mm.split(":"))
        return datetime(y, m, d, hh, mm, tzinfo=self.tz)


### FILE: ./pillsbot/debug_ids.py
# pillsbot/debug_ids.py
from __future__ import annotations

import sys
from typing import Iterable, Optional, Dict, Tuple

from aiogram.types import Message
from aiogram import Bot


async def _name_tuple_from_user(u) -> Tuple[Optional[str], Optional[str]]:
    username = u.username or None
    realname = f"{u.first_name or ''} {u.last_name or ''}".strip() or None
    return username, realname


async def print_group_and_users_best_effort(
    bot: Bot,
    message: Message,
    known_user_ids: Optional[Iterable[int]] = None,
) -> None:
    """
    Print to stdout:
      - group_id
      - For each participant we can discover: user_id, @username, real name
    No messages are sent or deleted in chat; no state is changed.

    Strategy (best-effort, platform-appropriate):
      1) Include chat administrators (get_chat_administrators).
      2) Include the message sender (if any).
      3) Include the bot itself.
      4) Include any known user ids (e.g., patient, nurse) via get_chat_member.
         This covers non-admin, silent members (like a nurse who hasn't spoken).
    """
    chat = message.chat
    group_id = chat.id

    users: Dict[int, Tuple[Optional[str], Optional[str]]] = {}

    # 1) Admins
    try:
        admins = await bot.get_chat_administrators(group_id)
        for a in admins:
            u = a.user
            users[u.id] = await _name_tuple_from_user(u)
    except Exception:
        pass  # ignore, proceed with other sources

    # 2) Sender
    if message.from_user:
        u = message.from_user
        users.setdefault(u.id, await _name_tuple_from_user(u))

    # 3) Bot itself
    try:
        me = await bot.get_me()
        users.setdefault(me.id, await _name_tuple_from_user(me))
    except Exception:
        pass

    # 4) Known user ids (patient, nurse) — fetch membership info even if not admins/senders
    if known_user_ids:
        for uid in known_user_ids:
            try:
                member = await bot.get_chat_member(group_id, uid)
                u = member.user
                users.setdefault(u.id, await _name_tuple_from_user(u))
            except Exception:
                # If not found or inaccessible, still record the raw uid
                users.setdefault(uid, (None, None))

    # Print to console/stdout
    print(f"group_id={group_id}", file=sys.stdout, flush=True)
    for uid, (uname, realname) in users.items():
        print(
            f"user_id={uid} username={uname!r} name={realname!r}",
            file=sys.stdout,
            flush=True,
        )


### FILE: ./pillsbot/__init__.py


