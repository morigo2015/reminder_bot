### FILE: ./bot.py
import logging
import asyncio

from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.events import (
    EVENT_JOB_ADDED,
    EVENT_JOB_SUBMITTED,
    EVENT_JOB_EXECUTED,
    EVENT_JOB_ERROR,
)

from config.config import BOT_TOKEN
from handlers.confirmation import router as confirmation_router
from handlers.pressure import router as pressure_router
from handlers.health_status import router as status_router
from services.log_service import LogService
from services.reminder_manager import ReminderManager
from flow_engine import FlowEngine

# ——— Logger setup —————————————————————————————————————————————————————————
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)s %(name)s — %(message)s",
)
logger = logging.getLogger(__name__)

# ——— Bot, Dispatcher, Scheduler ————————————————————————————————————————————
bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

scheduler = AsyncIOScheduler(timezone="Europe/Kyiv")


def _log_scheduler_event(event):
    job = scheduler.get_job(event.job_id)
    if event.code == EVENT_JOB_ADDED:
        logger.debug(
            f"[SCHEDULER] Added job {event.job_id!r}: next run at {job.next_run_time}"
        )
    elif event.code == EVENT_JOB_SUBMITTED:
        logger.debug(f"[SCHEDULER] Job {event.job_id!r} submitted to executor")
    elif event.code == EVENT_JOB_EXECUTED:
        logger.debug(f"[SCHEDULER] Job {event.job_id!r} executed successfully")
    elif event.code == EVENT_JOB_ERROR:
        logger.error(
            f"[SCHEDULER] Job {event.job_id!r} raised error: {event.exception!r}"
        )


async def main():
    # Attach debug listener
    scheduler.add_listener(
        _log_scheduler_event,
        EVENT_JOB_ADDED | EVENT_JOB_SUBMITTED | EVENT_JOB_EXECUTED | EVENT_JOB_ERROR,
    )
    scheduler.start()

    # Init services
    log_service = LogService()
    manager = ReminderManager(bot, dp, scheduler, log_service)

    dp["log_service"] = log_service
    dp["reminder_manager"] = manager

    # Register Telegram handlers
    dp.include_router(confirmation_router)
    dp.include_router(pressure_router)
    dp.include_router(status_router)

    # Schedule flows from YAML using FlowEngine
    flow = FlowEngine(bot, dp, scheduler, log_service)
    flow.start()

    # Log all scheduled jobs at startup
    for job in scheduler.get_jobs():
        logger.info(
            f"[SCHEDULER STARTUP] Job {job.id!r}: trigger={job.trigger!r}, "
            f"next_run={job.next_run_time}"
        )

    # Start polling
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())


### FILE: ./config/config.py
import os
from dotenv import load_dotenv

# Load .env from project root
load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
NURSE_CHAT_ID = int(os.getenv("NURSE_CHAT_ID", "0"))

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN not set in environment")

if NURSE_CHAT_ID == 0:
    # Will be used for escalation if needed
    raise RuntimeError("NURSE_CHAT_ID not set or invalid in environment")


### FILE: ./config/dialogs_config.yaml
# Regex patterns
patterns:
  confirmation_ok:
    - '(ok|okay|\+)'
    - '(так|да)'
    - 'вже (випив|випила|зробив|зробила)'
  pressure_prefix:
    - '^\s*(pressure|тиск)\b'
  health_prefix:
    - '^\s*(звіт|report|status)\b'

# Messages
messages:
  reminder:
    clarify: 'Не зрозуміла 🤔 Напишіть *так*, якщо вже виконали.'
    failed: 'Добре. Зараз попрошу медсестру прояснити.'
  nurse:
    clarification_failed: 'Пацієнт не підтвердив {event_name} після {attempts} запитів.'
  pressure:
    daily_reminder: 'Будь-ласка, виміряйте тиск і надішліть три числа (С/Д/ПБ).'

# Events
events:
  morning_med:
    trigger: "cron: 15 38"
    chat_id: 382163513
    retry_delay_seconds: 30
    main_text: 'Будь ласка, прийміть ранкові ліки 💊.'
    retry_text: 'Нагадування: ранкові ліки ще не прийняті 💊.'
    retries: 2
    escalate: true
  water:
    trigger: "cron: 8 0"
    chat_id: 382163513
    retry_delay_seconds: 180
    main_text: 'Випийте склянку води 🥤.'
    retry_text: 'Нагадую: випийте склянку води 🥤.'
    retries: 0
    escalate: false

  pressure_check:
    trigger: "cron: 23 25"     # runs every day at 12:00 Europe/Kyiv
    chat_id: 382163513         # ← same or different chat ID for testing
    main_text: "It's time for your daily blood-pressure check. Please use /pressure to log it."
    retries: 1
    retry_delay_seconds: 300   # 5 minutes
    retry_text: "Reminder: please log your blood pressure with /pressure."
    clarify_text: "Have you logged your blood pressure? (OK)"


# Timings
timings:
  clarify_delay_sec: 300
  clarify_retries: 2
  status_window_sec: 300
  pressure_remind_hour: 8
  log_msg_max: 250
  log_status_max_msgs: 10


### FILE: ./config/dialogs_loader.py
import yaml
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

CONFIG_PATH = Path(__file__).parent / "dialogs_config.yaml"

try:
    raw = yaml.safe_load(CONFIG_PATH.read_text(encoding="utf-8"))
except FileNotFoundError:
    logger.error(f"Dialogs config not found at {CONFIG_PATH}")
    raise

# Expose the full parsed YAML for things like patterns
RAW_CONFIG = raw

# Pull out just the events mapping for your reminder flows
DIALOGS = RAW_CONFIG.get("events", {})

# Validate each event has required keys
for key, cfg in DIALOGS.items():
    if "chat_id" not in cfg:
        logger.error(f"[DIALOGS LOADER] Missing `chat_id` for event '{key}'")
        raise KeyError(f"Missing `chat_id` for event '{key}'")
    if "trigger" not in cfg:
        logger.error(f"[DIALOGS LOADER] Missing `trigger` for event '{key}'")
        raise KeyError(f"Missing `trigger` for event '{key}'")


### FILE: ./flow_engine.py
# flow_engine.py

import logging
from apscheduler.triggers.cron import CronTrigger

from config.dialogs_loader import DIALOGS
from services.reminder_manager import ReminderManager

logger = logging.getLogger(__name__)


class FlowEngine:
    """
    Schedules all reminder flows defined in config/dialogs_config.yaml.
    """

    def __init__(self, bot, dispatcher, scheduler, log_service):
        """
        :param bot: Aiogram Bot instance
        :param dispatcher: Aiogram Dispatcher instance
        :param scheduler: APScheduler AsyncIOScheduler instance
        :param log_service: logging adapter (e.g. CSV or DB)
        """
        self.bot = bot
        self.dispatcher = dispatcher
        self.scheduler = scheduler
        self.manager = ReminderManager(bot, dispatcher, scheduler, log_service)

    def start(self):
        """
        Schedule every event under DIALOGS as a cron job.
        The scheduler itself is started in bot.py.
        """
        for event_name, cfg in DIALOGS.items():
            trigger_spec = cfg.get("trigger", "")
            if not trigger_spec.startswith("cron:"):
                logger.warning(
                    f"[FLOW ENGINE] Unsupported trigger '{trigger_spec}' for '{event_name}'"
                )
                continue

            try:
                _, spec = trigger_spec.split(":", 1)
                hour_str, minute_str = spec.strip().split()
                hour, minute = int(hour_str), int(minute_str)
            except Exception as e:
                logger.error(f"[FLOW ENGINE] Invalid cron spec for '{event_name}': {e}")
                continue

            chat_id = cfg["chat_id"]
            user_id = chat_id  # private chats

            trigger = CronTrigger(
                hour=hour, minute=minute, timezone=self.scheduler.timezone
            )
            job_id = f"reminder_{event_name}"

            logger.debug(
                f"[FLOW ENGINE] Scheduling '{event_name}' ({job_id}) at {hour:02d}:{minute:02d} for chat {chat_id}"
            )

            self.scheduler.add_job(
                self.manager.start_flow,
                trigger=trigger,
                kwargs={"event_name": event_name, "user_id": user_id},
                id=job_id,
                replace_existing=True,
            )

        logger.info("[FLOW ENGINE] All jobs scheduled")


### FILE: ./handlers/confirmation.py
# handlers/confirmation.py

import logging

from aiogram import Router, F
from aiogram.filters import StateFilter
from aiogram.types import Message
from aiogram.fsm.context import FSMContext

from config.dialogs_loader import RAW_CONFIG
from states import ReminderStates

logger = logging.getLogger(__name__)
router = Router()

_OK_SET = set()
for entry in RAW_CONFIG["patterns"]["confirmation_ok"]:
    pat = entry.strip().lstrip("^").rstrip("$")
    if pat.startswith("(") and pat.endswith(")"):
        pat = pat[1:-1]
    for choice in pat.split("|"):
        _OK_SET.add(choice.strip().lower())


def is_confirm(text: str) -> bool:
    return text.strip().lower() in _OK_SET


@router.message(
    StateFilter(ReminderStates.waiting_confirmation),
    F.text.func(is_confirm),
)
async def handle_confirmation(message: Message, state: FSMContext):
    data = await state.get_data()
    event_name = data["event"]
    chat_id = message.chat.id
    user_id = message.from_user.id

    logger.debug(f"[CONFIRM] '{message.text}' → cancel '{event_name}'")
    manager = state.dispatcher["reminder_manager"]
    await manager.cancel_flow(event_name, chat_id, user_id)
    await message.reply("Дякую, підтверджено! ✅")


@router.message(
    StateFilter(ReminderStates.waiting_clarification),
    F.text.func(is_confirm),
)
async def handle_clarification_confirmation(message: Message, state: FSMContext):
    data = await state.get_data()
    event_name = data["event"]
    chat_id = message.chat.id
    user_id = message.from_user.id

    logger.debug(f"[CLARIFY] '{message.text}' → finalize '{event_name}'")
    manager = state.dispatcher["reminder_manager"]
    await manager.finalize_flow(event_name, chat_id, user_id)
    await message.reply("Дякую за відповідь! 👍")


### FILE: ./handlers/health_status.py
from aiogram import Router, F
from aiogram.types import Message

router = Router()
STATUS_COMMANDS = ["/status", "звіт", "report"]


@router.message(F.text.startswith(tuple(STATUS_COMMANDS)))
async def status_handler(message: Message):
    """Collects health-status messages and logs them with a rolling window."""
    log_service = message.bot.dispatcher["log_service"]
    await log_service.status(message.chat.id, message.text, dropped=False)
    await message.answer("📝 Status recorded.")


### FILE: ./handlers/pressure.py
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext

from states import ReminderStates
from services.log_service import LogService

router = Router()
log_service = LogService()


@router.message(F.text.startswith("/pressure") | F.text.startswith("/bp"))
async def pressure_entry(message: Message, state: FSMContext):
    """
    Starts the blood-pressure entry flow.
    """
    await state.set_state(ReminderStates.entering_pressure)
    await message.reply(
        "Please enter your blood pressure as systolic/diastolic (e.g. 120/80):"
    )


@router.message(ReminderStates.entering_pressure)
async def pressure_record(message: Message, state: FSMContext):
    """
    Records the pressure reading and clears state.
    """
    text = message.text.strip()
    # Basic parse: "120/80"
    try:
        systolic, diastolic = map(int, text.split("/"))
    except ValueError:
        return await message.reply(
            "Invalid format. Please use systolic/diastolic (e.g. 120/80)."
        )

    # Log the values
    await log_service.pressure(
        chat_id=message.chat.id, systolic=systolic, diastolic=diastolic
    )
    await message.reply(f"Logged your blood pressure: {systolic}/{diastolic}. Thanks!")
    await state.clear()


### FILE: ./__init__.py


### FILE: ./scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler

def create_scheduler():
    # Use Kyiv timezone by default
    return AsyncIOScheduler(timezone='Europe/Kyiv')


### FILE: ./services/__init__.py


### FILE: ./services/logging.py
import os
import csv
import datetime
from asyncio import Lock

class CSVLogger:
    _locks = {}
    def __init__(self, type_name: str):
        self.type_name = type_name
        base = os.path.join(os.path.dirname(__file__), "..", "data", "logs")
        os.makedirs(base, exist_ok=True)
        self.path = os.path.join(base, f"{type_name}.csv")
        if not os.path.exists(self.path):
            with open(self.path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                if type_name == "reminder":
                    writer.writerow(["timestamp", "chat_id", "event_key", "action"])
                elif type_name == "pressure":
                    writer.writerow(["timestamp", "chat_id", "systolic", "diastolic", "pulse"])
                elif type_name == "status":
                    writer.writerow(["timestamp", "chat_id", "messages"])
        if type_name not in CSVLogger._locks:
            CSVLogger._locks[type_name] = Lock()
        self._lock = CSVLogger._locks[type_name]

    async def log(self, chat_id: int, **data):
        async with self._lock:
            with open(self.path, "a", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                row = [datetime.datetime.utcnow().isoformat(), chat_id]
                if self.type_name == "reminder":
                    row.extend([data["event_key"], data["action"]])
                elif self.type_name == "pressure":
                    row.extend([data["systolic"], data["diastolic"], data["pulse"]])
                elif self.type_name == "status":
                    row.append(data["messages"])
                writer.writerow(row)


### FILE: ./services/log_service.py
import csv
import os
from datetime import datetime

class LogService:
    def __init__(self, base_path='logs'):
        self.base_path = base_path
        os.makedirs(base_path, exist_ok=True)

    def _log(self, filename, row):
        path = os.path.join(self.base_path, filename)
        write_header = not os.path.exists(path)
        with open(path, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            if write_header:
                writer.writerow(row.keys())
            writer.writerow(row.values())

    async def pressure(self, chat_id, high, low, pulse):
        row = {
            'timestamp': datetime.utcnow().isoformat(),
            'CHAT_ID': chat_id,
            'HIGH': high,
            'LOW': low,
            'PULSE': pulse,
        }
        self._log('pressure.csv', row)

    async def status(self, chat_id, text, dropped):
        row = {
            'timestamp': datetime.utcnow().isoformat(),
            'CHAT_ID': chat_id,
            'STATUS': text,
            'DROPPED': dropped,
        }
        self._log('status.csv', row)

    async def confirmation(self, chat_id, event_name, status, attempts, clarifications):
        row = {
            'timestamp': datetime.utcnow().isoformat(),
            'CHAT_ID': chat_id,
            'EVENT': event_name,
            'STATUS': status,
            'ATTEMPTS': attempts,
            'CLARIFICATIONS': clarifications,
        }
        self._log('confirmation.csv', row)


### FILE: ./services/reminder_manager.py
# services/reminder_manager.py

import logging
from datetime import datetime, timedelta
from aiogram import Bot
from aiogram.fsm.storage.base import StorageKey

from config.dialogs_loader import DIALOGS
from states import ReminderStates

logger = logging.getLogger(__name__)


class ReminderManager:
    def __init__(self, bot: Bot, dispatcher, scheduler, log_service):
        self.bot = bot
        self.dp = dispatcher
        self.storage = dispatcher.storage
        self.scheduler = scheduler
        self.log = log_service

    def _make_key(self, chat_id: int, user_id: int) -> StorageKey:
        return StorageKey(chat_id, user_id, str(self.bot.id))

    async def start_flow(self, event_name: str, user_id: int):
        cfg = DIALOGS[event_name]
        chat_id = cfg["chat_id"]

        await self.bot.send_message(chat_id, cfg["main_text"])
        logger.debug(f"[REMINDER] Sent '{event_name}' to chat {chat_id}")

        key = self._make_key(chat_id, user_id)
        await self.storage.set_state(key, ReminderStates.waiting_confirmation)
        await self.storage.update_data(
            key,
            {
                "event": event_name,
                "attempts": 0,
                "clarifications": 0,
                "confirmed": False,
            },
        )

        retries = cfg.get("retries", 0)
        delay = cfg.get("retry_delay_seconds", 0)
        if retries and delay:
            await self._schedule_retry(
                event_name, chat_id, user_id, attempt=1, delay=delay
            )

    async def _schedule_retry(
        self, event_name: str, chat_id: int, user_id: int, attempt: int, delay: int
    ):
        next_run = datetime.now(self.scheduler.timezone) + timedelta(seconds=delay)
        job_id = f"retry_{event_name}_{chat_id}_{user_id}_{attempt}"
        logger.debug(f"[RETRY] #{attempt} for '{event_name}' at {next_run}")

        self.scheduler.add_job(
            self._handle_retry,
            trigger="date",
            run_date=next_run,
            kwargs={
                "event_name": event_name,
                "chat_id": chat_id,
                "user_id": user_id,
                "attempt": attempt,
            },
            id=job_id,
            replace_existing=True,
        )

    async def _handle_retry(
        self, event_name: str, chat_id: int, user_id: int, attempt: int
    ):
        key = self._make_key(chat_id, user_id)
        data = await self.storage.get_data(key)
        if data.get("confirmed"):
            return

        cfg = DIALOGS[event_name]
        await self.bot.send_message(chat_id, cfg["retry_text"])
        logger.debug(f"[RETRY] Fired #{attempt} for '{event_name}'")

        await self.storage.update_data(key, {"attempts": attempt})

        max_retries = cfg.get("retries", 0)
        delay = cfg.get("retry_delay_seconds", 0)
        if attempt < max_retries:
            await self._schedule_retry(event_name, chat_id, user_id, attempt + 1, delay)
        else:
            await self._start_clarification(event_name, chat_id, user_id)

    async def _start_clarification(self, event_name: str, chat_id: int, user_id: int):
        cfg = DIALOGS[event_name]
        await self.bot.send_message(
            chat_id, cfg.get("clarify_text", "Please confirm (OK)")
        )
        logger.debug(f"[CLARIFY] for '{event_name}'")

        key = self._make_key(chat_id, user_id)
        await self.storage.set_state(key, ReminderStates.waiting_clarification)
        await self.storage.update_data(key, {"clarifications": 1})

    async def cancel_flow(self, event_name: str, chat_id: int, user_id: int):
        prefix = f"{event_name}_{chat_id}_{user_id}"
        for job in self.scheduler.get_jobs():
            if prefix in job.id:
                job.remove()

        key = self._make_key(chat_id, user_id)
        data = await self.storage.get_data(key)
        await self.log.confirmation(
            chat_id=chat_id,
            event=event_name,
            status="confirmed",
            attempts=data.get("attempts", 0),
            clarifications=data.get("clarifications", 0),
        )
        await self.storage.reset_state(key)

    async def finalize_flow(self, event_name: str, chat_id: int, user_id: int):
        prefix = f"{event_name}_{chat_id}_{user_id}"
        for job in self.scheduler.get_jobs():
            if prefix in job.id:
                job.remove()

        key = self._make_key(chat_id, user_id)
        data = await self.storage.get_data(key)
        await self.log.confirmation(
            chat_id=chat_id,
            event=event_name,
            status="clarified",
            attempts=data.get("attempts", 0),
            clarifications=data.get("clarifications", 0),
        )
        await self.storage.reset_state(key)


### FILE: ./services/status_window.py
"""Manage per‑chat health status collection windows."""
from __future__ import annotations
from collections import defaultdict, deque
from datetime import datetime, timedelta
from typing import Deque, Dict, List

from ..utils.time import kyiv_now
from ..utils import logging as log

class StatusWindowManager:
    """Tracks open status windows and stored messages."""

    def __init__(self, window_sec: int, msg_limit: int):
        self.window_sec = window_sec
        self.msg_limit = msg_limit
        # chat_id -> (window_end, deque[str])
        self._windows: Dict[int, tuple[datetime, Deque[str]]] = {}

    def add_message(self, chat_id: int, text: str) -> None:
        now = kyiv_now()
        window_end, msgs = self._windows.get(chat_id, (now, deque()))
        if now >= window_end:
            # start new window
            window_end = now + timedelta(seconds=self.window_sec)
            msgs = deque()
        # store message or mark dropped
        if len(msgs) < self.msg_limit:
            msgs.append(text)
            log.log_status(text, dropped=False)
        else:
            log.log_status(text, dropped=True)
        self._windows[chat_id] = (window_end, msgs)

### FILE: ./states.py
from aiogram.fsm.state import StatesGroup, State


class ReminderStates(StatesGroup):
    waiting_confirmation = State()
    waiting_clarification = State()
    entering_pressure = State()


