### FILE: ./bot.py
import logging
import asyncio
from aiogram import Bot, Dispatcher
from aiogram.fsm.storage.memory import MemoryStorage
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.events import (
    EVENT_JOB_ADDED,
    EVENT_JOB_SUBMITTED,
    EVENT_JOB_EXECUTED,
    EVENT_JOB_ERROR,
)

from config.config import BOT_TOKEN
from handlers.confirmation import router as confirmation_router
from handlers.pressure import router as pressure_router
from handlers.health_status import router as status_router
from services.log_service import LogService
from services.reminder_manager import ReminderManager
from flow_engine import FlowEngine

# â€”â€”â€” Logger setup â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
logging.basicConfig(
    level=logging.DEBUG,
    format="%(asctime)s %(levelname)s %(name)s â€” %(message)s",
)
logger = logging.getLogger(__name__)

# â€”â€”â€” Bot, Dispatcher, Scheduler â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”â€”
bot = Bot(token=BOT_TOKEN)
storage = MemoryStorage()
dp = Dispatcher(storage=storage)

scheduler = AsyncIOScheduler(timezone="Europe/Kyiv")


def _log_scheduler_event(event):
    job = scheduler.get_job(event.job_id)
    if event.code == EVENT_JOB_ADDED:
        logger.debug(
            f"[SCHEDULER] Added job {event.job_id!r}: next run at {job.next_run_time}"
        )
    elif event.code == EVENT_JOB_SUBMITTED:
        logger.debug(f"[SCHEDULER] Job {event.job_id!r} submitted to executor")
    elif event.code == EVENT_JOB_EXECUTED:
        logger.debug(f"[SCHEDULER] Job {event.job_id!r} executed successfully")
    elif event.code == EVENT_JOB_ERROR:
        logger.error(
            f"[SCHEDULER] Job {event.job_id!r} raised error: {event.exception!r}"
        )


async def main():
    # Attach debug listener
    scheduler.add_listener(
        _log_scheduler_event,
        EVENT_JOB_ADDED | EVENT_JOB_SUBMITTED | EVENT_JOB_EXECUTED | EVENT_JOB_ERROR,
    )
    scheduler.start()

    # Init services
    log_service = LogService()
    manager = ReminderManager(bot, dp, scheduler, log_service)

    dp["log_service"] = log_service
    dp["reminder_manager"] = manager

    # Register Telegram handlers
    dp.include_router(confirmation_router)
    dp.include_router(pressure_router)
    dp.include_router(status_router)

    # Schedule flows from YAML
    flow = FlowEngine(scheduler, manager)
    flow.schedule_events()

    # Log all scheduled jobs at startup
    for job in scheduler.get_jobs():
        logger.info(
            f"[SCHEDULER STARTUP] Job {job.id!r}: trigger={job.trigger!r}, next_run={job.next_run_time}"
        )

    # Start polling
    await dp.start_polling(bot)


if __name__ == "__main__":
    asyncio.run(main())


### FILE: ./config/config.py
import os
from dotenv import load_dotenv

# Load .env from project root
load_dotenv()

BOT_TOKEN = os.getenv("BOT_TOKEN")
NURSE_CHAT_ID = int(os.getenv("NURSE_CHAT_ID", "0"))

if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN not set in environment")

if NURSE_CHAT_ID == 0:
    # Will be used for escalation if needed
    raise RuntimeError("NURSE_CHAT_ID not set or invalid in environment")


### FILE: ./config/dialogs_config.yaml
# Regex patterns
patterns:
  confirmation_ok:
    - '(ok|okay|\+)'
    - '(Ñ‚Ð°Ðº|Ð´Ð°)'
    - 'Ð²Ð¶Ðµ (Ð²Ð¸Ð¿Ð¸Ð²|Ð²Ð¸Ð¿Ð¸Ð»Ð°|Ð·Ñ€Ð¾Ð±Ð¸Ð²|Ð·Ñ€Ð¾Ð±Ð¸Ð»Ð°)'
  pressure_prefix:
    - '^\s*(pressure|Ñ‚Ð¸ÑÐº)\b'
  health_prefix:
    - '^\s*(Ð·Ð²Ñ–Ñ‚|report|status)\b'

# Messages
messages:
  reminder:
    clarify: 'ÐÐµ Ð·Ñ€Ð¾Ð·ÑƒÐ¼Ñ–Ð»Ð° ðŸ¤” ÐÐ°Ð¿Ð¸ÑˆÑ–Ñ‚ÑŒ *Ñ‚Ð°Ðº*, ÑÐºÑ‰Ð¾ Ð²Ð¶Ðµ Ð²Ð¸ÐºÐ¾Ð½Ð°Ð»Ð¸.'
    failed: 'Ð”Ð¾Ð±Ñ€Ðµ. Ð—Ð°Ñ€Ð°Ð· Ð¿Ð¾Ð¿Ñ€Ð¾ÑˆÑƒ Ð¼ÐµÐ´ÑÐµÑÑ‚Ñ€Ñƒ Ð¿Ñ€Ð¾ÑÑÐ½Ð¸Ñ‚Ð¸.'
  nurse:
    clarification_failed: 'ÐŸÐ°Ñ†Ñ–Ñ”Ð½Ñ‚ Ð½Ðµ Ð¿Ñ–Ð´Ñ‚Ð²ÐµÑ€Ð´Ð¸Ð² {event_name} Ð¿Ñ–ÑÐ»Ñ {attempts} Ð·Ð°Ð¿Ð¸Ñ‚Ñ–Ð².'
  pressure:
    daily_reminder: 'Ð‘ÑƒÐ´ÑŒ-Ð»Ð°ÑÐºÐ°, Ð²Ð¸Ð¼Ñ–Ñ€ÑÐ¹Ñ‚Ðµ Ñ‚Ð¸ÑÐº Ñ– Ð½Ð°Ð´Ñ–ÑˆÐ»Ñ–Ñ‚ÑŒ Ñ‚Ñ€Ð¸ Ñ‡Ð¸ÑÐ»Ð° (Ð¡/Ð”/ÐŸÐ‘).'

# Events
events:
  morning_med:
    trigger: "cron: 23 50"
    chat_id: 382163513
    retry_delay_seconds: 30
    main_text: 'Ð‘ÑƒÐ´ÑŒ Ð»Ð°ÑÐºÐ°, Ð¿Ñ€Ð¸Ð¹Ð¼Ñ–Ñ‚ÑŒ Ñ€Ð°Ð½ÐºÐ¾Ð²Ñ– Ð»Ñ–ÐºÐ¸ ðŸ’Š.'
    retry_text: 'ÐÐ°Ð³Ð°Ð´ÑƒÐ²Ð°Ð½Ð½Ñ: Ñ€Ð°Ð½ÐºÐ¾Ð²Ñ– Ð»Ñ–ÐºÐ¸ Ñ‰Ðµ Ð½Ðµ Ð¿Ñ€Ð¸Ð¹Ð½ÑÑ‚Ñ– ðŸ’Š.'
    retries: 2
    escalate: true
  water:
    trigger: "cron: 8 0"
    chat_id: 382163513
    retry_delay_seconds: 180
    main_text: 'Ð’Ð¸Ð¿Ð¸Ð¹Ñ‚Ðµ ÑÐºÐ»ÑÐ½ÐºÑƒ Ð²Ð¾Ð´Ð¸ ðŸ¥¤.'
    retry_text: 'ÐÐ°Ð³Ð°Ð´ÑƒÑŽ: Ð²Ð¸Ð¿Ð¸Ð¹Ñ‚Ðµ ÑÐºÐ»ÑÐ½ÐºÑƒ Ð²Ð¾Ð´Ð¸ ðŸ¥¤.'
    retries: 0
    escalate: false

  pressure_check:
    trigger: "cron: 23 25"     # runs every day at 12:00 Europe/Kyiv
    chat_id: 382163513         # â† same or different chat ID for testing
    main_text: "It's time for your daily blood-pressure check. Please use /pressure to log it."
    retries: 1
    retry_delay_seconds: 300   # 5 minutes
    retry_text: "Reminder: please log your blood pressure with /pressure."
    clarify_text: "Have you logged your blood pressure? (OK)"


# Timings
timings:
  clarify_delay_sec: 300
  clarify_retries: 2
  status_window_sec: 300
  pressure_remind_hour: 8
  log_msg_max: 250
  log_status_max_msgs: 10


### FILE: ./config/dialogs_loader.py
import yaml
import logging
from pathlib import Path

logger = logging.getLogger(__name__)

CONFIG_PATH = Path(__file__).parent / "dialogs_config.yaml"

try:
    raw = yaml.safe_load(CONFIG_PATH.read_text(encoding="utf-8"))
except FileNotFoundError:
    logger.error(f"Dialogs config not found at {CONFIG_PATH}")
    raise

# Expose the full parsed YAML for things like patterns
RAW_CONFIG = raw

# Pull out just the events mapping for your reminder flows
DIALOGS = RAW_CONFIG.get("events", {})

# Validate each event has required keys
for key, cfg in DIALOGS.items():
    if "chat_id" not in cfg:
        logger.error(f"[DIALOGS LOADER] Missing `chat_id` for event '{key}'")
        raise KeyError(f"Missing `chat_id` for event '{key}'")
    if "trigger" not in cfg:
        logger.error(f"[DIALOGS LOADER] Missing `trigger` for event '{key}'")
        raise KeyError(f"Missing `trigger` for event '{key}'")


### FILE: ./flow_engine.py
import logging
from apscheduler.triggers.cron import CronTrigger
from config.dialogs_loader import DIALOGS
from services.reminder_manager import ReminderManager

logger = logging.getLogger(__name__)


class FlowEngine:
    def __init__(self, scheduler, reminder_manager: ReminderManager):
        self.scheduler = scheduler
        self.reminder_manager = reminder_manager

    def schedule_events(self):
        for event_name, cfg in DIALOGS.items():
            trigger_spec = cfg["trigger"]
            if trigger_spec.startswith("cron:"):
                try:
                    # Expect "cron: HH MM"
                    _, spec = trigger_spec.split(":", 1)
                    hour_str, minute_str = spec.strip().split()
                    hour, minute = int(hour_str), int(minute_str)

                    trigger = CronTrigger(
                        hour=hour, minute=minute, timezone=self.scheduler.timezone
                    )
                    job_id = f"reminder_{event_name}"
                    logger.debug(
                        f"[FLOW ENGINE] Scheduling '{event_name}' ({job_id}) at {hour:02d}:{minute:02d}"
                    )
                    self.scheduler.add_job(
                        self.reminder_manager.start_flow,
                        trigger=trigger,
                        args=[event_name],
                        id=job_id,
                        replace_existing=True,
                    )
                    job = self.scheduler.get_job(job_id)
                    logger.debug(
                        f"[FLOW ENGINE] â†’ next run for {job_id!r}: {job.next_run_time}"
                    )
                except Exception as e:
                    logger.error(
                        f"[FLOW ENGINE] Invalid cron spec for '{event_name}': {e}"
                    )
            else:
                logger.warning(
                    f"[FLOW ENGINE] Unsupported trigger '{trigger_spec}' for '{event_name}'"
                )


### FILE: ./handlers/confirmation.py
# handlers/confirmation.py

import logging
import re

from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext

from config.dialogs_loader import RAW_CONFIG
from states import ReminderStates

logger = logging.getLogger(__name__)
router = Router()

# Build confirmation regex from YAMLâ€™s patterns.confirmation_ok
pattern_list = RAW_CONFIG["patterns"]["confirmation_ok"]
# Wrap each pattern in a non-capturing group, then join with |
joined = "|".join(f"(?:{p})" for p in pattern_list)
# Final regex anchors the full text
CONFIRM_PATTERN = re.compile(rf"^(?:{joined})$", re.IGNORECASE)


@router.message(ReminderStates.waiting_confirmation, F.text.regexp(CONFIRM_PATTERN))
async def handle_confirmation(message: Message, state: FSMContext):
    """
    Catches confirmation replies during waiting_confirmation state,
    using the YAML-defined patterns.confirmation_ok.
    """
    data = await state.get_data()
    event_name = data.get("event")
    chat_id = message.chat.id

    manager = state.dispatcher["reminder_manager"]
    logger.debug(
        f"[CONFIRMATION] '{message.text}' matches pattern; canceling '{event_name}'"
    )

    await manager.cancel_flow(event_name, chat_id)
    await message.reply("Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾, Ð¿Ð¾Ð´Ñ‚Ð²ÐµÑ€Ð¶ÐµÐ½Ð¾! âœ…")


@router.message(ReminderStates.waiting_clarification, F.text.regexp(CONFIRM_PATTERN))
async def handle_clarification_confirmation(message: Message, state: FSMContext):
    """
    Catches confirmation replies during waiting_clarification state,
    again using the same YAML patterns.
    """
    data = await state.get_data()
    event_name = data.get("event")
    chat_id = message.chat.id

    manager = state.dispatcher["reminder_manager"]
    logger.debug(
        f"[CLARIFICATION] '{message.text}' matches pattern; finalizing '{event_name}'"
    )

    await manager.finalize_flow(event_name, chat_id)
    await message.reply("Ð¡Ð¿Ð°ÑÐ¸Ð±Ð¾ Ð·Ð° Ð¾Ñ‚Ð²ÐµÑ‚! ðŸ‘")


### FILE: ./handlers/health_status.py
from aiogram import Router, F
from aiogram.types import Message

router = Router()
STATUS_COMMANDS = ["/status", "Ð·Ð²Ñ–Ñ‚", "report"]


@router.message(F.text.startswith(tuple(STATUS_COMMANDS)))
async def status_handler(message: Message):
    """Collects health-status messages and logs them with a rolling window."""
    log_service = message.bot.dispatcher["log_service"]
    await log_service.status(message.chat.id, message.text, dropped=False)
    await message.answer("ðŸ“ Status recorded.")


### FILE: ./handlers/pressure.py
from aiogram import Router, F
from aiogram.types import Message
from aiogram.fsm.context import FSMContext

from states import ReminderStates
from services.log_service import LogService

router = Router()
log_service = LogService()


@router.message(F.text.startswith("/pressure") | F.text.startswith("/bp"))
async def pressure_entry(message: Message, state: FSMContext):
    """
    Starts the blood-pressure entry flow.
    """
    await state.set_state(ReminderStates.entering_pressure)
    await message.reply(
        "Please enter your blood pressure as systolic/diastolic (e.g. 120/80):"
    )


@router.message(ReminderStates.entering_pressure)
async def pressure_record(message: Message, state: FSMContext):
    """
    Records the pressure reading and clears state.
    """
    text = message.text.strip()
    # Basic parse: "120/80"
    try:
        systolic, diastolic = map(int, text.split("/"))
    except ValueError:
        return await message.reply(
            "Invalid format. Please use systolic/diastolic (e.g. 120/80)."
        )

    # Log the values
    await log_service.pressure(
        chat_id=message.chat.id, systolic=systolic, diastolic=diastolic
    )
    await message.reply(f"Logged your blood pressure: {systolic}/{diastolic}. Thanks!")
    await state.clear()


### FILE: ./__init__.py


### FILE: ./scheduler.py
from apscheduler.schedulers.asyncio import AsyncIOScheduler

def create_scheduler():
    # Use Kyiv timezone by default
    return AsyncIOScheduler(timezone='Europe/Kyiv')


### FILE: ./services/__init__.py


### FILE: ./services/logging.py
import os
import csv
import datetime
from asyncio import Lock

class CSVLogger:
    _locks = {}
    def __init__(self, type_name: str):
        self.type_name = type_name
        base = os.path.join(os.path.dirname(__file__), "..", "data", "logs")
        os.makedirs(base, exist_ok=True)
        self.path = os.path.join(base, f"{type_name}.csv")
        if not os.path.exists(self.path):
            with open(self.path, "w", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                if type_name == "reminder":
                    writer.writerow(["timestamp", "chat_id", "event_key", "action"])
                elif type_name == "pressure":
                    writer.writerow(["timestamp", "chat_id", "systolic", "diastolic", "pulse"])
                elif type_name == "status":
                    writer.writerow(["timestamp", "chat_id", "messages"])
        if type_name not in CSVLogger._locks:
            CSVLogger._locks[type_name] = Lock()
        self._lock = CSVLogger._locks[type_name]

    async def log(self, chat_id: int, **data):
        async with self._lock:
            with open(self.path, "a", newline="", encoding="utf-8") as f:
                writer = csv.writer(f)
                row = [datetime.datetime.utcnow().isoformat(), chat_id]
                if self.type_name == "reminder":
                    row.extend([data["event_key"], data["action"]])
                elif self.type_name == "pressure":
                    row.extend([data["systolic"], data["diastolic"], data["pulse"]])
                elif self.type_name == "status":
                    row.append(data["messages"])
                writer.writerow(row)


### FILE: ./services/log_service.py
import csv
import os
from datetime import datetime

class LogService:
    def __init__(self, base_path='logs'):
        self.base_path = base_path
        os.makedirs(base_path, exist_ok=True)

    def _log(self, filename, row):
        path = os.path.join(self.base_path, filename)
        write_header = not os.path.exists(path)
        with open(path, 'a', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            if write_header:
                writer.writerow(row.keys())
            writer.writerow(row.values())

    async def pressure(self, chat_id, high, low, pulse):
        row = {
            'timestamp': datetime.utcnow().isoformat(),
            'CHAT_ID': chat_id,
            'HIGH': high,
            'LOW': low,
            'PULSE': pulse,
        }
        self._log('pressure.csv', row)

    async def status(self, chat_id, text, dropped):
        row = {
            'timestamp': datetime.utcnow().isoformat(),
            'CHAT_ID': chat_id,
            'STATUS': text,
            'DROPPED': dropped,
        }
        self._log('status.csv', row)

    async def confirmation(self, chat_id, event_name, status, attempts, clarifications):
        row = {
            'timestamp': datetime.utcnow().isoformat(),
            'CHAT_ID': chat_id,
            'EVENT': event_name,
            'STATUS': status,
            'ATTEMPTS': attempts,
            'CLARIFICATIONS': clarifications,
        }
        self._log('confirmation.csv', row)


### FILE: ./services/reminder_manager.py
import logging
from datetime import datetime, timedelta
from aiogram import Bot
from aiogram.fsm.storage.base import StorageKey

from config.dialogs_loader import DIALOGS
from states import ReminderStates

logger = logging.getLogger(__name__)


class ReminderManager:
    def __init__(self, bot: Bot, dispatcher, scheduler, log_service):
        """
        :param bot: Aiogram Bot instance
        :param dispatcher: Aiogram Dispatcher instance
        :param scheduler: APScheduler AsyncIOScheduler instance
        :param log_service: your logging adapter (e.g. CSV or DB logger)
        """
        self.bot = bot
        self.dp = dispatcher
        self.storage = dispatcher.storage
        self.scheduler = scheduler
        self.log = log_service

    def _make_key(self, chat_id: int, user_id: int) -> StorageKey:
        # bot_id must be string
        return StorageKey(chat_id, user_id, str(self.bot.id))

    async def start_flow(self, event_name: str):
        """
        1. Send main reminder text.
        2. Set FSM to waiting_confirmation.
        3. Schedule retry(s).
        """
        cfg = DIALOGS[event_name]
        chat_id = cfg["chat_id"]
        main_text = cfg["main_text"]

        await self.bot.send_message(chat_id, main_text)
        logger.debug(f"[REMINDER] Sent main_text for '{event_name}' to chat {chat_id}")

        key = self._make_key(chat_id, chat_id)
        await self.storage.set_state(key, ReminderStates.waiting_confirmation)
        await self.storage.update_data(
            key,
            {
                "event": event_name,
                "attempts": 0,
                "clarifications": 0,
                "confirmed": False,
            },
        )

        # Schedule first retry if configured
        retries = cfg.get("retries", 0)
        delay = cfg.get("retry_delay_seconds", 0)
        if retries > 0 and delay > 0:
            await self._schedule_retry(event_name, chat_id, attempt=1, delay=delay)

    async def _schedule_retry(
        self, event_name: str, chat_id: int, attempt: int, delay: int
    ):
        """
        Schedule a one-off retry `delay` seconds in the future.
        """
        next_run = datetime.utcnow() + timedelta(seconds=delay)
        job_id = f"retry_{event_name}_{chat_id}_{attempt}"
        logger.debug(
            f"[RETRY] Scheduling retry #{attempt} for '{event_name}' at {next_run} (id={job_id})"
        )

        self.scheduler.add_job(
            self._handle_retry,
            trigger="date",
            run_date=next_run,
            kwargs={"event_name": event_name, "chat_id": chat_id, "attempt": attempt},
            id=job_id,
            replace_existing=True,
        )

    async def _handle_retry(self, event_name: str, chat_id: int, attempt: int):
        """
        Called by APScheduler when a retry is due.
        """
        key = self._make_key(chat_id, chat_id)
        data = await self.storage.get_data(key)
        if data.get("confirmed"):
            logger.debug(f"[RETRY] '{event_name}' already confirmed; skipping retry.")
            return

        cfg = DIALOGS[event_name]
        retry_text = cfg["retry_text"]

        await self.bot.send_message(chat_id, retry_text)
        logger.debug(
            f"[REMINDER] Fired retry #{attempt} for '{event_name}' to chat {chat_id}"
        )

        await self.storage.update_data(key, {"attempts": attempt})

        max_retries = cfg.get("retries", 0)
        delay = cfg.get("retry_delay_seconds", 0)

        if attempt < max_retries:
            await self._schedule_retry(event_name, chat_id, attempt + 1, delay)
        else:
            await self._start_clarification(event_name, chat_id)

    async def _start_clarification(self, event_name: str, chat_id: int):
        """
        After all retries exhausted, ask for clarification.
        """
        cfg = DIALOGS[event_name]
        clarify_text = cfg.get("clarify_text", "Please confirm (OK)")

        await self.bot.send_message(chat_id, clarify_text)
        logger.debug(
            f"[CLARIFY] Starting clarification for '{event_name}' to chat {chat_id}"
        )

        key = self._make_key(chat_id, chat_id)
        await self.storage.set_state(key, ReminderStates.waiting_clarification)
        await self.storage.update_data(key, {"clarifications": 1})

    async def cancel_flow(self, event_name: str, chat_id: int):
        """
        User confirmed in time:
        - Remove pending jobs
        - Log confirmation
        - Reset FSM
        """
        # Cancel scheduled jobs
        for job in list(self.scheduler.get_jobs()):
            if job.id.startswith(f"retry_{event_name}_{chat_id}") or job.id.startswith(
                f"clarify_{event_name}_{chat_id}"
            ):
                job.remove()
                logger.debug(f"[CANCEL] Removed job {job.id!r}")

        key = self._make_key(chat_id, chat_id)
        data = await self.storage.get_data(key)
        await self.log.confirmation(
            chat_id=chat_id,
            event=event_name,
            status="confirmed",
            attempts=data.get("attempts", 0),
            clarifications=data.get("clarifications", 0),
        )

        # Clear FSM
        await self.storage.reset_state(key)

    async def finalize_flow(self, event_name: str, chat_id: int):
        """
        User responded during clarification:
        - Remove pending jobs
        - Log as 'clarified'
        - Reset FSM
        """
        for job in list(self.scheduler.get_jobs()):
            if job.id.startswith(f"retry_{event_name}_{chat_id}") or job.id.startswith(
                f"clarify_{event_name}_{chat_id}"
            ):
                job.remove()
                logger.debug(f"[FINALIZE] Removed job {job.id!r}")

        key = self._make_key(chat_id, chat_id)
        data = await self.storage.get_data(key)
        await self.log.confirmation(
            chat_id=chat_id,
            event=event_name,
            status="clarified",
            attempts=data.get("attempts", 0),
            clarifications=data.get("clarifications", 0),
        )

        # Clear FSM
        await self.storage.reset_state(key)


### FILE: ./services/status_window.py
"""Manage perâ€‘chat health status collection windows."""
from __future__ import annotations
from collections import defaultdict, deque
from datetime import datetime, timedelta
from typing import Deque, Dict, List

from ..utils.time import kyiv_now
from ..utils import logging as log

class StatusWindowManager:
    """Tracks open status windows and stored messages."""

    def __init__(self, window_sec: int, msg_limit: int):
        self.window_sec = window_sec
        self.msg_limit = msg_limit
        # chat_id -> (window_end, deque[str])
        self._windows: Dict[int, tuple[datetime, Deque[str]]] = {}

    def add_message(self, chat_id: int, text: str) -> None:
        now = kyiv_now()
        window_end, msgs = self._windows.get(chat_id, (now, deque()))
        if now >= window_end:
            # start new window
            window_end = now + timedelta(seconds=self.window_sec)
            msgs = deque()
        # store message or mark dropped
        if len(msgs) < self.msg_limit:
            msgs.append(text)
            log.log_status(text, dropped=False)
        else:
            log.log_status(text, dropped=True)
        self._windows[chat_id] = (window_end, msgs)

### FILE: ./states.py
from aiogram.fsm.state import StatesGroup, State


class ReminderStates(StatesGroup):
    waiting_confirmation = State()
    waiting_clarification = State()
    entering_pressure = State()


